{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-11-03-wraper-de-streams-php/","result":{"data":{"site":{"siteMetadata":{"title":"Dias de Dev","siteUrl":"https://dias.dev"}},"markdownRemark":{"id":"67b92626-1fe4-564c-8606-b97962ee757e","excerpt":"Streams Antes de falarmos sobre um wrapper específico, é legal dar um certo contexto sobre streams. Um stream basicamente é um fluxo de dados. Usando streams…","html":"<h2>Streams</h2>\n<p>Antes de falarmos sobre um wrapper específico, é legal dar um certo contexto sobre streams.</p>\n<p>Um stream basicamente é um fluxo de dados. Usando streams podemos realizar operações de I/O como leitura de arquivos,\nacessos a rede, comunicação por sockets e muito mais.</p>\n<p>Existem muitas funcionalidades que giram em torno dos streams do PHP como filtros, contextos, etc,\nmas neste artigo meu foco vai ser em um wrapper específico.</p>\n<h2>Wrappers</h2>\n<p>Wrappers de streams em PHP são o código que diz como aquele determinado protocolo vai ser usado e gerenciado.</p>\n<p>Ler um arquivo é diferente de realizar uma requisição HTTP que é diferente de se conectar com um Unix socket.\nPara que todas essas diferenças sejam abstraídas para nós devs, o PHP fornece wrappers.</p>\n<p>Quando você abre um arquivo para leitura em PHP, usa o wrapper <code class=\"language-text\">file://</code>.\nQuando faz uma requisição HTTP, usa o wrapper <code class=\"language-text\">http://</code>.\nCom wrappers diferentes, podemos utilizar o mesmo código para realizar tarefas completamente diferentes. Ex.:</p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token php language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\n<span class=\"token keyword\">echo</span> <span class=\"token function\">file_get_contents</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'file://arquivo.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// lê um arquivo</span>\n<span class=\"token keyword\">echo</span> <span class=\"token function\">file_get_contents</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'http://google.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// faz uma requisição HTTP</span></span></code></pre></div>\n<h3>Wrappers disponíveis</h3>\n<p>Por padrão o PHP já fornece diversos wrappers como</p>\n<ul>\n<li><code class=\"language-text\">file://</code></li>\n<li><code class=\"language-text\">http://</code> e <code class=\"language-text\">https://</code></li>\n<li><code class=\"language-text\">ftp://</code></li>\n<li><code class=\"language-text\">zlib://</code></li>\n<li><code class=\"language-text\">ssh2://</code></li>\n<li><code class=\"language-text\">rar://</code></li>\n<li>etc</li>\n</ul>\n<p>Existem outros wrappers fornecidos por padrão e além disso nós podemos criar nossos próprios wrappers.\nMas isso foge do escopo desse artigo e no final dele vou deixar alguns links de referências.</p>\n<h2>Wrapper php://</h2>\n<p>Um dos wrappers mais interessantes e que menos vejo material sobre é o <code class=\"language-text\">php://</code>.\nAtravés dele temos acesso a diversos recursos de I/O como a entrada e saída padrão do sistema, streams temporários em\ndisco e em memória, etc.</p>\n<p>Vamos ver de forma resumida algumas das possibilidades deste wrapper</p>\n<h3>php://input</h3>\n<p>Este provavelmente é o stream mais utilizado fornecido por este wrapper. Através dele nós conseguimos acessar diretamente\no corpo de uma requisição. Então se uma requisição <code class=\"language-text\">POST</code> é feita para seu sistema enviando o corpo em JSON, por exemplo,\no seguinte código pode fazer o parse:</p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token php language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\n<span class=\"token variable\">$corpo</span> <span class=\"token operator\">=</span> <span class=\"token function\">file_get_contents</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'php://input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// recupera o corpo todo da requisição, como string</span>\n<span class=\"token variable\">$json</span> <span class=\"token operator\">=</span> <span class=\"token function\">json_decode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$corpo</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// decodifica a string em json</span>\n\n<span class=\"token keyword\">echo</span> <span class=\"token variable\">$json</span><span class=\"token operator\">-></span><span class=\"token property\">algumValor</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// acessa um valor já parseado</span></span></code></pre></div>\n<p>É válido citar que este stream permite apenas a leitura, logo, não podemos escrever nada nele. </p>\n<h3>php://memory e php://temp</h3>\n<p>Ambos streams são de leitura e escrita, e nos permitem acesso a um espaço que pode ser no disco ou na RAM para manipular\ndados temporários. São interessantes para realizar processamentos em dados já existentes usando a interface de streams,\npor exemplo.</p>\n<p><code class=\"language-text\">php://memory</code> vai manter todo o dado na RAM enquanto <code class=\"language-text\">php://temp</code> vai utilizar um arquivo quando o conteúdo do stream\natingir um limite de tamanho pré-definido (2MB por padrão).</p>\n<h3>php://filter</h3>\n<p>Aplicar filtros de streams pode trazer grandes poderes para sua aplicação e até poupar bastante uso de memória.\nMas para utilizar filtros, teoricamente nós precisaríamos de um recurso de stream aberto. Qual o problema disso?\nNão poderíamos usar filtros com funções como <code class=\"language-text\">file_get_contents</code> que ao invés de um recurso, recebe uma string por\nparâmetro.</p>\n<p>Usando o stream <code class=\"language-text\">php://filter</code> nós podemos especificar filtros para esse tipo de função sem nenhum problema. Exemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token php language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\n<span class=\"token keyword\">echo</span> <span class=\"token function\">file_get_contents</span><span class=\"token punctuation\">(</span><span class=\"token string double-quoted-string\">\"php://filter/read=string.toupper|string.rot13/resource=http://www.example.com\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span></code></pre></div>\n<p>Isso vai aplicar os filtros <code class=\"language-text\">string.toupper</code> e <code class=\"language-text\">string.rot13</code> ao ler de <em><a href=\"http://www.example.com\">http://www.example.com</a></em>.</p>\n<p>Se você não conhece os filtros de streams, vale a pena conferir as referências no final do artigo. ;-)</p>\n<h3>php://stdin, php://stdout e php://stderr</h3>\n<p>Estes streams fornecem acesso aos streams correspondentes do próprio processo do PHP.\n<code class=\"language-text\">php://stdin</code> fornece acesso à entrada padrão do processo (que pode ser o teclado ou um pipe, por exemplo).\n<code class=\"language-text\">php://stdout</code> permite acessar a saída padrão, que pode ser o terminal em uma aplicação CLI.\n<code class=\"language-text\">php://stderr</code> nos deixa escrever na saída de erro do processo.</p>\n<p>O primeiro stream é apenas para leitura, enquanto os 2 outros são apenas para escrita. Não é possível escrever em\n<code class=\"language-text\">php://stdin</code> por exemplo.</p>\n<h3>php://output</h3>\n<p>Este stream permite escrever no mecanismo de buffer de saída do PHP, assim como <code class=\"language-text\">echo</code> e <code class=\"language-text\">print</code> fazem.</p>\n<h3>php://output vs php://stdout</h3>\n<p>Você talvez esteja se perguntando a diferença entre <code class=\"language-text\">php://output</code> e <code class=\"language-text\">php://stdout</code>.\nBasicamente o primeiro escreve no mecanismo de buffer de saída do PHP, o que permite o controle através de funções\ncomo <code class=\"language-text\">ob_start</code>. Já o segundo escreve direto na saída do processo, não passando pelo controle de buffer do PHP.</p>\n<p>Para entender melhor:</p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token php language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\n<span class=\"token variable\">$stdout</span> <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'php://stdout'</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">'w'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$output</span> <span class=\"token operator\">=</span> <span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string single-quoted-string\">'php://output'</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">'w'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">ob_start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">fwrite</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$output</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">'Escrevendo no output'</span> <span class=\"token operator\">.</span> <span class=\"token constant\">PHP_EOL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fwrite</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$stdout</span><span class=\"token punctuation\">,</span> <span class=\"token string single-quoted-string\">'Escrevendo na saída padrão'</span> <span class=\"token operator\">.</span> <span class=\"token constant\">PHP_EOL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">ob_end_flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span></code></pre></div>\n<p>Ao executar este script em um terminal, o primeiro <code class=\"language-text\">fwrite</code> envia a string para o mecanismo de buffer do PHP, e devido\nao <code class=\"language-text\">ob_start()</code>, não vai ser imprimido ainda. O segundo <code class=\"language-text\">fwrite</code> manda o conteúdo direto para a saída (tela do terminal).\nAo executar <code class=\"language-text\">ob_end_flush()</code> o buffer é enviado para a saída do processo, então o resultado é:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Escrevendo na saída padrão\nEscrevendo no output</code></pre></div>\n<h3>Buffer de saída</h3>\n<p>Se você não entendeu bem essa parte de buffer de saída e quiser que eu faça um artigo específico sobre isso, é só me\ncontar nos comentários que eu preparo pra você! :-D</p>\n<h2>Conclusão</h2>\n<p>Analisando apenas um dos possíveis wrappers dá pra ter uma breve noção de como essa feature do PHP é poderosa. Através\nde streams podemos compactar e descompactar arquivos, enviar dados por FTP, acessar servidores via SSH e muito mais.</p>\n<h3>Referências</h3>\n<p>Conforme prometido, vou deixar aqui alguns links para que você possa se aprofundar nesse assunto tão rico e importante.</p>\n<ul>\n<li>\n<p><a href=\"https://www.youtube.com/watch?v=ZRYMzS97HVQ\">https://www.youtube.com/watch?v=ZRYMzS97HVQ</a></p>\n<ul>\n<li>Nessa palestra o <a href=\"https://twitter.com/alganet\">Alexandre Gaigalas</a> mostra um pouco do poder dos streams</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.php.net/manual/en/book.stream.php\">https://www.php.net/manual/en/book.stream.php</a></p>\n<ul>\n<li>A documentação oficial é sempre um ótimo lugar para recorrer e entender a fundo as funcionalidades</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://cursos.alura.com.br/course/php-io-arquivos-streams\">https://cursos.alura.com.br/course/php-io-arquivos-streams</a></p>\n<ul>\n<li>Na Alura existe um curso específico de streams usando filtros, contextos e muito mais</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/2020-09-16-php-assincrono-de-forma-nativa/\">PHP Assíncrono de Forma Nativa</a></p>\n<ul>\n<li>Aqui mesmo no blog tem um post onde uso streams para realizar programação assíncrona através de I/O não bloqueante.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Wrapper de Streams php://","date":"03 de novembro de 2020","description":"Streams em PHP são muito poderosos mas pouco difundidos e divulgados. Neste artigo vamos falar do wrapper php://"}}},"pageContext":{"slug":"/2020-11-03-wraper-de-streams-php/","previous":{"fields":{"slug":"/2020-10-27-php-alem-da-web/"},"frontmatter":{"title":"PHP além da Web"}},"next":{"fields":{"slug":"/2021-03-13-requisicoes-http-paralelas-com-php/"},"frontmatter":{"title":"Requisições HTTP paralelas com PHP"}}}},"staticQueryHashes":["2841359383","3257411868"]}