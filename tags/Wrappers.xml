<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Dias de Dev]]></title>
    <link href="https://dias.dev//tags/Wrappers.xml" rel="self"/>
    <link href="https://dias.dev//"/>
    <updated>2022-02-10T03:26:17+00:00</updated>
    <id>https://dias.dev//</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Wrapper de Streams php://]]></title>
            <link href="https://dias.dev//2020-11-03-wraper-de-streams-php/"/>
            <updated>2020-11-03T00:00:00+00:00</updated>
            <id>https://dias.dev//2020-11-03-wraper-de-streams-php/</id>
            <content type="html"><![CDATA[<h2 id="streams">Streams</h2>

<p>Antes de falarmos sobre um wrapper específico, é legal dar um certo contexto sobre streams.</p>

<p>Um stream basicamente é um fluxo de dados. Usando streams podemos realizar operações de I/O como leitura de arquivos,
acessos a rede, comunicação por sockets e muito mais.</p>

<p>Existem muitas funcionalidades que giram em torno dos streams do PHP como filtros, contextos, etc,
mas neste artigo meu foco vai ser em um wrapper específico.</p>

<h2 id="wrappers">Wrappers</h2>

<p>Wrappers de streams em PHP são o código que diz como aquele determinado protocolo vai ser usado e gerenciado.</p>

<p>Ler um arquivo é diferente de realizar uma requisição HTTP que é diferente de se conectar com um Unix socket.
Para que todas essas diferenças sejam abstraídas para nós devs, o PHP fornece wrappers.</p>

<p>Quando você abre um arquivo para leitura em PHP, usa o wrapper <code>file://</code>.
Quando faz uma requisição HTTP, usa o wrapper <code>http://</code>.
Com wrappers diferentes, podemos utilizar o mesmo código para realizar tarefas completamente diferentes. Ex.:</p>

<pre><code class="php">&lt;?php

echo file_get_contents('file://arquivo.txt'); // lê um arquivo
echo file_get_contents('http://google.com'); // faz uma requisição HTTP
</code></pre>

<h3 id="wrappers-dispon%C3%ADveis">Wrappers disponíveis</h3>

<p>Por padrão o PHP já fornece diversos wrappers como</p>

<ul>
<li><code>file://</code></li>
<li><code>http://</code> e <code>https://</code></li>
<li><code>ftp://</code></li>
<li><code>zlib://</code></li>
<li><code>ssh2://</code></li>
<li><code>rar://</code></li>
<li>etc</li>
</ul>

<p>Existem outros wrappers fornecidos por padrão e além disso nós podemos criar nossos próprios wrappers.
Mas isso foge do escopo desse artigo e no final dele vou deixar alguns links de referências.</p>

<h2 id="wrapper-php%3A%2F%2F">Wrapper php://</h2>

<p>Um dos wrappers mais interessantes e que menos vejo material sobre é o <code>php://</code>.
Através dele temos acesso a diversos recursos de I/O como a entrada e saída padrão do sistema, streams temporários em
disco e em memória, etc.</p>

<p>Vamos ver de forma resumida algumas das possibilidades deste wrapper</p>

<h3 id="php%3A%2F%2Finput">php://input</h3>

<p>Este provavelmente é o stream mais utilizado fornecido por este wrapper. Através dele nós conseguimos acessar diretamente
o corpo de uma requisição. Então se uma requisição <code>POST</code> é feita para seu sistema enviando o corpo em JSON, por exemplo,
o seguinte código pode fazer o parse:</p>

<pre><code class="php">&lt;?php

$corpo = file_get_contents('php://input'); // recupera o corpo todo da requisição, como string
$json = json_decode($corpo); // decodifica a string em json

echo $json-&gt;algumValor; // acessa um valor já parseado
</code></pre>

<p>É válido citar que este stream permite apenas a leitura, logo, não podemos escrever nada nele.</p>

<h3 id="php%3A%2F%2Fmemory-e-php%3A%2F%2Ftemp">php://memory e php://temp</h3>

<p>Ambos streams são de leitura e escrita, e nos permitem acesso a um espaço que pode ser no disco ou na RAM para manipular
dados temporários. São interessantes para realizar processamentos em dados já existentes usando a interface de streams,
por exemplo.</p>

<p><code>php://memory</code> vai manter todo o dado na RAM enquanto <code>php://temp</code> vai utilizar um arquivo quando o conteúdo do stream
atingir um limite de tamanho pré-definido (2MB por padrão).</p>

<h3 id="php%3A%2F%2Ffilter">php://filter</h3>

<p>Aplicar filtros de streams pode trazer grandes poderes para sua aplicação e até poupar bastante uso de memória.
Mas para utilizar filtros, teoricamente nós precisaríamos de um recurso de stream aberto. Qual o problema disso?
Não poderíamos usar filtros com funções como <code>file_get_contents</code> que ao invés de um recurso, recebe uma string por
parâmetro.</p>

<p>Usando o stream <code>php://filter</code> nós podemos especificar filtros para esse tipo de função sem nenhum problema. Exemplo:</p>

<pre><code class="php">&lt;?php

echo file_get_contents("php://filter/read=string.toupper|string.rot13/resource=http://www.example.com");

</code></pre>

<p>Isso vai aplicar os filtros <code>string.toupper</code> e <code>string.rot13</code> ao ler de <em>http://www.example.com</em>.</p>

<p>Se você não conhece os filtros de streams, vale a pena conferir as referências no final do artigo. ;-)</p>

<h3 id="php%3A%2F%2Fstdin%2C-php%3A%2F%2Fstdout-e-php%3A%2F%2Fstderr">php://stdin, php://stdout e php://stderr</h3>

<p>Estes streams fornecem acesso aos streams correspondentes do próprio processo do PHP.
<code>php://stdin</code> fornece acesso à entrada padrão do processo (que pode ser o teclado ou um pipe, por exemplo).
<code>php://stdout</code> permite acessar a saída padrão, que pode ser o terminal em uma aplicação CLI.
<code>php://stderr</code> nos deixa escrever na saída de erro do processo.</p>

<p>O primeiro stream é apenas para leitura, enquanto os 2 outros são apenas para escrita. Não é possível escrever em
<code>php://stdin</code> por exemplo.</p>

<h3 id="php%3A%2F%2Foutput">php://output</h3>

<p>Este stream permite escrever no mecanismo de buffer de saída do PHP, assim como <code>echo</code> e <code>print</code> fazem.</p>

<h3 id="php%3A%2F%2Foutput-vs-php%3A%2F%2Fstdout">php://output vs php://stdout</h3>

<p>Você talvez esteja se perguntando a diferença entre <code>php://output</code> e <code>php://stdout</code>.
Basicamente o primeiro escreve no mecanismo de buffer de saída do PHP, o que permite o controle através de funções
como <code>ob_start</code>. Já o segundo escreve direto na saída do processo, não passando pelo controle de buffer do PHP.</p>

<p>Para entender melhor:</p>

<pre><code class="php">&lt;?php

$stdout = fopen('php://stdout', 'w');
$output = fopen('php://output', 'w');

ob_start();

fwrite($output, 'Escrevendo no output' . PHP_EOL);
fwrite($stdout, 'Escrevendo na saída padrão' . PHP_EOL);

ob_end_flush();
</code></pre>

<p>Ao executar este script em um terminal, o primeiro <code>fwrite</code> envia a string para o mecanismo de buffer do PHP, e devido
ao <code>ob_start()</code>, não vai ser imprimido ainda. O segundo <code>fwrite</code> manda o conteúdo direto para a saída (tela do terminal).
Ao executar <code>ob_end_flush()</code> o buffer é enviado para a saída do processo, então o resultado é:</p>

<pre><code>Escrevendo na saída padrão
Escrevendo no output
</code></pre>

<h3 id="buffer-de-sa%C3%ADda">Buffer de saída</h3>

<p>Se você não entendeu bem essa parte de buffer de saída e quiser que eu faça um artigo específico sobre isso, é só me
contar nos comentários que eu preparo pra você! :-D</p>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Analisando apenas um dos possíveis wrappers dá pra ter uma breve noção de como essa feature do PHP é poderosa. Através
de streams podemos compactar e descompactar arquivos, enviar dados por FTP, acessar servidores via SSH e muito mais.</p>

<h3 id="refer%C3%AAncias">Referências</h3>

<p>Conforme prometido, vou deixar aqui alguns links para que você possa se aprofundar nesse assunto tão rico e importante.</p>

<ul>
<li>https://www.youtube.com/watch?v=ZRYMzS97HVQ

<ul>
<li>Nessa palestra o <a href="https://twitter.com/alganet">Alexandre Gaigalas</a> mostra um pouco do poder dos streams</li>
</ul></li>
<li>https://www.php.net/manual/en/book.stream.php

<ul>
<li>A documentação oficial é sempre um ótimo lugar para recorrer e entender a fundo as funcionalidades</li>
</ul></li>
<li>https://cursos.alura.com.br/course/php-io-arquivos-streams

<ul>
<li>Na Alura existe um curso específico de streams usando filtros, contextos e muito mais. Se quiser 10% de desconto na sua assinatura, confere <a href="https://www.alura.com.br/promocao/diasdedev">esse link aqui</a>.</li>
</ul></li>
<li><a href="/2020-09-16-php-assincrono-de-forma-nativa/">PHP Assíncrono de Forma Nativa</a>

<ul>
<li>Aqui mesmo no blog tem um post onde uso streams para realizar programação assíncrona através de I/O não bloqueante.</li>
</ul></li>
</ul>
]]></content>
        </entry>
    </feed>