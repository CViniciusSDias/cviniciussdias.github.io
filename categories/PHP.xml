<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Dias de Dev]]></title>
    <link href="https://dias.dev/categories/PHP.xml" rel="self"/>
    <link href="https://dias.dev"/>
    <updated>2024-04-10T03:03:21+00:00</updated>
    <id>https://dias.dev/</id>
            <author>
            <name><![CDATA[Vinicius Dias]]></name>            <email><![CDATA[vinicius@dias.dev]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[PHP Strict Types: Entendendo o Uso Prático da Diretiva declare(strict_types=1) no PHP]]></title>
            <link href="https://dias.dev/2023-12-28-entendendo-strict-types-no-php/"/>
            <updated>2023-12-28T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-12-28-entendendo-strict-types-no-php/</id>
            <content type="html"><![CDATA[<p>A diretiva <code>declare(strict_types=1)</code> é amplamente utilizada no PHP, mas nem todos entendem o que ela faz na prática. Nesse texto nós vamos entender como o comportamento do seu código pode ser alterado ao usar essa diretiva.</p>

<h2 id="type-hints-no-php">Type hints no PHP</h2>

<p>O PHP possui o conceito de <em>Type Hints</em> que é basicamente como nós podemos informar os tipos que usaremos em alguns locais como em parâmetros e retornos de funções. Ao informar o tipo de um parâmetro, por exemplo, o PHP irá verificar se o valor passado é compatível com o tipo informado. Por exemplo:</p>

<pre><code class="php">function soma(int $a, int $b): int
{
    return $a + $b;
}

soma('test 1', 'test 2'); // Fatal error: Uncaught TypeError: Argument 1 passed to soma() must be of the type int, string given
</code></pre>

<p>Repare que ao tentar passar uma string para uma função que espera inteiros, um erro do tipo <code>TypeError</code> é lançado. Esse tipo de técnica traz mais segurança para nosso código de forma que conhecemos melhor os valores que manipulamos.</p>

<h2 id="malabarismo-com-tipos">Malabarismo com tipos</h2>

<p>Embora o PHP possua os famosos e muito úteis <em>type hints</em>, é importante dizer que nem sempre eles são seguidos à risca. O PHP possui outro conceito chamado <em>type juggling</em> (malabarismo de tipos em tradução livre) que é basicamente a conversão de tipos de forma implícita. Essa funcionalidade permite algumas facilidades bem interessantes, principalmente quando nos lembramos que o protocolo HTTP trabalha somente com texto. Se nós recebessemos os dois números para realizar a soma por uma requisição, eles viriam como <code>string</code>s, então o seguinte código seria executado:</p>

<pre><code class="php">soma('1', '2'); // 3
</code></pre>

<p>Embora ainda estejamos passando strings por parâmetro, agora a chamada da função é bem sucedida. Isso acontece, pois o PHP possui algo chamado <a href="https://www.youtube.com/watch?v=sKw-ruVP9cw">strings numéricas</a>. O exemplo anterior é um caso onde a conversão automática dos tipos nos ajuda, porém há casos onde isso pode ser um problema. Se nós tentarmos passar números com ponto flutuante, por exemplo, o PHP irá remover a parte decimal dos números:</p>

<pre><code class="php">soma(1.5, 2.5); // 3
</code></pre>

<p>Desde a versão 8.1 o PHP emitirá um aviso de obsolência (<em>deprecation notice</em>) quando tentamos converter <code>float</code> para <code>int</code>, mas ainda assim o código é executado e o resultado é no mínimo inesperado (para não dizer incorreto).</p>

<h2 id="impedindo-convers%C3%B5es">Impedindo conversões</h2>

<p>Para impedir esse comportamento do PHP, nós podemos usar a diretiva <code>declare(strict_types=1)</code> que irá forçar o PHP a seguir os <em>type hints</em> de forma mais rígida, sem conversões implícitas de tipos. Ao usar essa diretiva, o PHP irá lançar um erro do tipo <code>TypeError</code> quando tentarmos passar um tipo diferente do esperado, mesmo que seja possível realizar alguma conversão. Sendo assim, se onde eu chamo a função <code>soma</code> houver a declaração de <code>strict_types</code>, o código lançará um erro:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

function soma(int $a, int $b): int
{
    return $a + $b;
}

soma('1', '2'); // Fatal error: Uncaught TypeError: Argument 1 passed to soma() must be of the type int, string given
soma(1.5, 2.5); // Fatal error: Uncaught TypeError: Argument 1 passed to soma() must be of the type int, float given
</code></pre>

<p>Um detalhe muito importante é que a diretiva <code>declare(strict_types=1)</code> deve ser declarada no início do arquivo, antes de qualquer código.</p>

<h2 id="m%C3%BAltiplos-arquivos">Múltiplos arquivos</h2>

<p>A diretiva <code>declare</code> agirá no arquivo onde ela for declarada, então pode acontecer de termos um arquivo com <code>strict_types=1</code> e outro sem. Nesse cenário, o PHP vai se comportar seguindo o que for declarado no arquivo que <strong>chama</strong> a função e não no arquivo que a declara. Exemplo:</p>

<pre><code class="php">&lt;?php
// arquivo functions.php

declare(strict_types=1);

function soma(int $a, int $b) {
    return $a + $b;
}
?&gt;

&lt;?php
// arquivo index.php

require_once 'functions.php';

echo soma('1', '2'); // 3
?&gt;
</code></pre>

<p>Repare que mesmo o arquivo <code>functions.php</code> possuindo a diretiva, o arquivo que executa a função é o <code>index.php</code> e ele não informa a diretiva, logo, ela estará desabilitada. Já no caso contrário, o seguinte ocorrerá:</p>

<pre><code class="php">// arquivo functions.php

function soma(int $a, int $b) {
    return $a + $b;
}
?&gt;

&lt;?php
// arquivo index.php

declare(strict_types=1);

require_once 'functions.php';

echo soma('1', '2'); // Fatal error: Uncaught TypeError: Argument 1 passed to soma() must be of the type int, string given
?&gt;
</code></pre>

<p>Mesmo o arquivo <code>functions.php</code> não informando a diretiva <code>declare(strict_types=1)</code> o erro acontece, pois no arquivo <code>index.php</code> é onde a chamada acontece e ele possui a diretiva.</p>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Tipos em PHP podem ser um assunto espinhoso porque além de complexo, nem todo dev concorda em como utilizá-los. Uns (como eu) acreditam que quanto mais estrito, melhor. Outros acreditam que <em>type hints</em> são um desperdício. Mais uma coisa eu acredito que seja unânime: é muito importante para nós, como devs PHP, entender como os tipos funcionam na linguagem com a qual trabalhamos.</p>

<p>Se você deseja explorar ainda mais o tema de tipos em PHP, recomendo a leitura de um artigo abrangente no blog Codamos. O conteúdo discute detalhadamente os diversos tipos em PHP, suas manipulações e conversões, e oferece uma análise mais aprofundada sobre <code>strict_types</code>, inclusive com trechos de código em C do PHP. Para acessar o artigo completo, visite <a href="https://codamos.com.br/tipos-em-php/">este link</a>. E se você quiser aprender mais sobre PHP, há <strong>muitos</strong> cursos gravados por mim lá na Alura. Aqui tem um <a href="https://tidd.ly/4d42Myb">cupom de 10% de desconto</a> para assinar a plataforma.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Executando Funções Rust em PHP com FFI: Um Guia Passo a Passo]]></title>
            <link href="https://dias.dev/2023-12-18-usando-rust-com-php-e-ffi/"/>
            <updated>2023-12-18T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-12-18-usando-rust-com-php-e-ffi/</id>
            <content type="html"><![CDATA[<p>Usando FFI (<em>Foreign Function Interface</em>) é possível executar código de outras linguagens em PHP. Neste artigo, vamos ver como executar funções escritas em Rust a partir do PHP usando FFI.</p>

<h2 id="ffi">FFI</h2>

<p>FFI não é uma particularidade do PHP, mas sim uma técnica que permite que uma linguagem de programação execute código de outra linguagem. Desde sua versão 7.4, o PHP possui uma <a href="/2022-02-13-extensoes-php">extensão</a> chamada FFI que permite o uso dessa técnica.</p>

<p>Para usar FFI, precisamos ter um arquivo compilado em formato de biblioteca. Normalmente são arquivos <code>.so</code> no Linux e <code>.dll</code> no Windows. Esses arquivos podem ser gerados a partir de código escrito em C, C++ ou Rust, por exemplo.</p>

<h2 id="gerando-uma-biblioteca-em-rust">Gerando uma biblioteca em Rust</h2>

<p>Entendido o conceito de FFI e sabendo que é possível executar essa técnica com PHP, vamos criar uma biblioteca em Rust. Esse texto não tem a intenção de ser um tutorial de Rust, então vou assumir que você já possua o Rust e Cargo instalados corretamente em seu computador.</p>

<p>Para criar um novo projeto em Rust, execute o comando abaixo em uma pasta da sua escolha:</p>

<pre><code class="bash">cargo new --lib nossa-biblioteca
</code></pre>

<p>Com isso, alguns arquivos serão criados. Você terá o arquivo de configuração do projeto chamado <code>Cargo.toml</code> e o arquivo <code>lib.rs</code> que é o arquivo principal da biblioteca.</p>

<p>No arquivo <code>Cargo.toml</code>, vamos adicionar a seguinte configuração:</p>

<pre><code class="toml">[lib]
crate-type = ["cdylib"]
</code></pre>

<p>Com isso, nós informamos ao Cargo que ao compilar nosso projeto, ele deve gerar uma biblioteca que pode ser utilizada por outras linguagens e não apenas por outros projetos Rust.</p>

<p>Se você executar o comando <code>cargo build</code>, o projeto recém-criado deve ser compilado sem nenhum problema.</p>

<h2 id="escrevendo-o-c%C3%B3digo-em-rust">Escrevendo o código em Rust</h2>

<p>Para que a função que nós vamos escrever possa ser executada por outras linguagens, precisamos adotar algumas práticas e é isso que veremos agora.</p>

<p>Nossa intenção é criar uma função que receba dois números e retorne a soma deles. No momento da escrita desse artigo, o código de <code>src/lib.rs</code> já possui uma função que faz isso, mas vamos alterá-la para que ela possa ser usada por outras linguagens. Esse é o código inicial ao criar a biblioteca:</p>

<pre><code class="rust">pub fn add(left: usize, right: usize) -&gt; usize {
    left + right
}
</code></pre>

<p>Vamos começar com os tipos. <code>usize</code> significa <em>unsigned size</em> e é um tipo que representa um número inteiro positivo. Nós queremos permitir o uso de números negativos também, então vamos alterar esse tipo. Para manter as coisas simples, vamos usar <code>i32</code> que é um inteiro de 32 bits. Isso é equivalente ao <code>int</code> de C em um sistema de 64 bits. Com essa alteração, nosso código fica assim:</p>

<pre><code class="rust">pub fn add(left: i32, right: i32) -&gt; i32 {
    left + right
}
</code></pre>

<h2 id="tornando-o-c%C3%B3digo-acess%C3%ADvel-por-outras-linguagens">Tornando o código acessível por outras linguagens</h2>

<p>Até agora escrevemos um código perfeitamente funcional em Rust, mas ele ainda não pode ser executado por outras linguagens que consigam executar bibliotecas. Ainda faltam algumas etapas.</p>

<p>A primeira é justamente informar que essa função chamada <code>add</code> pode ser chamada externamente. Isso é feito com a diretiva <code>extern "C"</code> do Rust. Ao adicionar <code>extern "C"</code> antes de <code>fn</code> nós informamos que a função a seguir será visível para outras linguagens.</p>

<p>Mas ainda falta um último detalhe. Ao compilar um código, todo compilador, independente da linguagem, realiza um processo chamado <em>Mangling</em>. Esse processo consiste em renomear a função para adicionar informações ou às vezes até para manipular o tamanho do binário resultante da compilação. O problema é que cada compilador faz isso de uma forma diferente e isso impede que uma função escrita em uma linguagem seja chamada por outra linguagem.</p>

<p>O Rust possui um atributo que, quando adicionado a uma função, informa ao compilador que esse processo não deve ser realizado. Dessa forma, nossa função chamada <code>add</code> continuará se chamando <code>add</code> mesmo após a compilacão. O nome do atributo é <code>#[no_mangle]</code> e ele deve ser adicionado antes da função. Com isso, nosso código fica assim:</p>

<pre><code class="rust">#[no_mangle]
pub extern "C" fn add(left: i32, right: i32) -&gt; i32 {
    left + right
}
</code></pre>

<p>Com isso, nosso código em Rust está pronto para ser executado por outras linguagens.</p>

<h2 id="compilando-a-biblioteca">Compilando a biblioteca</h2>

<p>Para compilar a biblioteca, basta executar o comando <code>cargo build</code> na pasta do projeto. O arquivo resultante da compilação estará em <code>target/debug/libnossa_biblioteca.so</code> no Linux ou <code>target/debug/nossa_biblioteca.dll</code> no Windows.</p>

<p>O arquivo resultante da compilação é uma biblioteca que pode ser usada por outras linguagens.</p>

<h2 id="usando-a-biblioteca-em-php">Usando a biblioteca em PHP</h2>

<p>Agora que temos um arquivo <code>.so</code> ou <code>.dll</code> gerado, podemos usá-lo em PHP. Para isso, vamos usar a extensão FFI.</p>

<p>Essa extensão possui algumas formas de ser utilizada e o propósito desse texto não é ser um tutorial sobre FFI também. Então vou seguir com a abordagem mais simples, que é informar dois parâmetros à função <code>FFI::cdef</code>: o primeiro é uma string contendo as assinaturas das funções que queremos usar e o segundo é o caminho para a biblioteca que queremos usar.</p>

<p>Vamos criar um arquivo <code>ffi.php</code> na mesma pasta desse nosso projeto em Rust para realizar o teste. Nosso código para utilizar a função <code>add</code> do arquivo <code>target/debug/libnossa_biblioteca.so</code> (troque por <code>.dll</code> no Windows) fica assim:</p>

<pre><code class="php">$ffi = FFI::cdef(
    'int add(int left, int right);',
    __DIR__ . '/target/debug/libnossa_biblioteca.so'
);

var_dump($ffi-&gt;add(1, 2));
</code></pre>

<p>Caso você tenha a extensão FFI instalada e habilitada, o resultado será <code>int(3)</code>. Isso significa que a função <code>add</code> foi executada corretamente e retornou o valor <code>3</code>.</p>

<h2 id="considera%C3%A7%C3%B5es-sobre-tipos">Considerações sobre tipos</h2>

<p>Repare que em Rust nós escrevemos <code>i32</code> como o tipo dos parâmetros e do retorno, enquanto no PHP nós usamos <code>int</code>. A extensão FFI espera como definição das funções uma assinatura compatível com C e o tipo <code>i32</code>, como foi citado anteriormente, é equivalente ao <code>int</code> de C. Por isso, podemos usar <code>int</code> no PHP sem problemas. Além disso, diversas conversões são feitas automaticamente pela extensão FFI, por isso o tipo <code>int</code> de C virou sem nenhum problema um <code>int</code> do PHP, embora por baixo dos panos eles sejam tipos bem diferentes.</p>

<h3 id="strings">Strings</h3>

<p>Tipos numéricos e booleanos são relativamente fáceis de se lidar, mas e quanto a strings? Como podemos passar uma string para o Rust e/ou receber uma string de volta?</p>

<p>O Rust possui um módulo chamado <code>std::ffi</code> que é exatamente pensado para trazer funcionalidades quando estivermos escrevendo código que pode interagir com outras linguagens. Um dos tipos presentes nesse módulo é o chamado <code>c_char</code> que é equivalente ao <code>char</code> de C. Com isso, uma string que em C é um ponteiro para um <code>char</code> pode ser representada em Rust como um ponteiro para um <code>c_char</code>. Logo, para receber uma string por parâmetro ou para retornar uma string, bastaria utilizarmos <code>*const c_char</code> como tipo.</p>

<p>Exemplo de função que recebe uma string e a retorna sem modificações:</p>

<pre><code class="rust">use std::ffi::c_char;

#[no_mangle]
pub extern "C" fn return_message(message: *const c_char) -&gt; *const c_char {
    message
}
</code></pre>

<p>Em PHP nós poderíamos chamar essa função da seguinte forma:</p>

<pre><code class="php">$ffi = FFI::cdef(
    'const char *return_message(const char *message);',
    __DIR__ . '/target/debug/libnossa_biblioteca.so'
);
var_dump($ffi-&gt;return_message('Hello, world!'));
</code></pre>

<p>E isso nos mostraria <code>string(13) "Hello, world!"</code>.</p>

<p>Porém, para manipularmos essa String em Rust, um ponteiro para <code>c_char</code> não seria a melhor forma. Então podemos usar o tipo <code>std::ffi::CStr</code> para transformar esse ponteiro em uma string manipulável da seguinte forma:</p>

<pre><code class="rust">let string: &amp;str = unsafe { CStr::from_ptr(message) }.to_str().unwrap();
</code></pre>

<p>Como estamos lidando com um ponteiro, o bloco <code>unsafe</code> é necessário. O método <code>to_str()</code> tenta transformar o <code>CStr</code> em uma string do Rust, mas isso pode falhar, então ele retorna um <code>Result</code>. Como sabemos que a string que estamos recebendo é válida, podemos usar o método <code>unwrap()</code> para obter a string sem precisar lidar com o <code>Result</code>.</p>

<p>Além de <code>CStr</code> há também o tipo <code>CString</code>. <code>CStr</code> está para <code>&amp;str</code> assim como <code>CString</code> está para <code>String</code> no Rust. Com isso nós já conseguimos lidar normalmente com strings em Rust.</p>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Já que é possível chamar códigos em Rust (ou outras linguagens como C ou C++) a partir do PHP, algumas tarefas que poderiam ser executadas de forma mais eficiente ou até de forma exclusiva a partir de linguagens compiladas ainda podem viver em projetos PHP.</p>

<p>Dois bons exemplos de caso de uso desse tipo de técnica são:</p>

<ol>
<li>pacote <code>php-tkui</code> que usa FFI para chamar o Tk, uma biblioteca gráfica escrita em C, o que permite <a href="https://youtube.com/watch?v=5yhJMcCVNSI">criação de aplicações desktop usando PHP</a></li>
<li>Computação de grandes arquivos JSON ou Markdown, que embora seja perfeitamente possível fazer diretamente me PHP, em alguns cenários pode se tornar mais eficiente usando Rust + FFI.</li>
</ol>

<p>Se você quiser aprender mais tanto sobre Rust quanto sobre PHP, há cursos gravados por mim lá na Alura. Aqui tem um <a href="https://tidd.ly/4d42Myb">cupom de 10% de desconto</a> para assinar a plataforma.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Novidades do PHP 8.3: O que há de novo nessa versão do PHP]]></title>
            <link href="https://dias.dev/2023-11-17-novidades-do-php-8-3/"/>
            <updated>2023-11-17T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-11-17-novidades-do-php-8-3/</id>
            <content type="html"><![CDATA[<p>A versão final do PHP 8.3 está agendada para ser lançada no dia <a href="https://wiki.php.net/todo/php83">23 de novembro de 2023</a> e traz algumas novidades bem interessantes, contando com novas funções, novas classes e código que passa a ser considerado obsoleto.</p>

<h2 id="modifica%C3%A7%C3%B5es-sobre-%60readonly%60">Modificações sobre <code>readonly</code></h2>

<p>Uma <em>RFC</em> intitulada <em>Readonly amendments</em> propõe duas mudanças em como a palavra-chave <code>readonly</code> se comporta, porém apenas uma dessas mudanças foi aceita. A partir da versão 8.3 do PHP, é possível reinicializar propriedades <code>readonly</code> ao clonar objetos, ou seja, dentro do <a href="/2023-08-11-metodos-magicos-php">método mágico</a> <code>__clone</code>.</p>

<p>Isso torna o seguinte código, que no PHP 8.2 causaria um erro, possível:</p>

<pre><code class="php">&lt;?php

readonly class Usuario
{
    public function __construct(
        public \DateTimeImmutable $nascimento, 
    ) {}

    public function __clone() : void
    {
        $this-&gt;nascimento = clone $this-&gt;nascimento;
    }
}
</code></pre>

<p>Essa funcionalidade, embora pareça pequena, permite que realizemos <em>deep copy</em> de objetos que possuam propriedades <code>readonly</code>.</p>

<p>Se quiser ver mais sobre essa nova funcionalidade, eu tenho um vídeo sobre ela em meu canal do YouTube:</p>

<p><lite-youtube videoid="yE2Ei9xsJnk">
    <a href="https://youtube.com/watch?v=yE2Ei9xsJnk" class="lite-youtube-fallback" title="Reproduzir vídeo">
        Novidades do PHP 8.3: Modificações sobre readonly | Dias de Dev
    </a>
</lite-youtube></p>

<h2 id="constantes-tipadas-em-classes">Constantes tipadas em classes</h2>

<p>A partir do PHP 8.3 é possível definirmos os tipos de constantes em nossas classes. Essa possibilidade nos traz mais segurança de tipos principalmente quando há herança entre classes ou implementação de interfaces que possuem constantes. Até o PHP 8.2, uma classe poderia sobrescrever uma constante herdada adicionando qualquer valor, sem checagem de tipo. Isso poderia trazer problemas como o seguinte:</p>

<pre><code class="php">interface InterfaceTeste {
    const TEST = "Test";
}

class ClasseBase implements InterfaceTeste {
    const TEST = []; // Mudamos o tipo aqui
}

class ClasseDerivada extends ClasseBase {
    const TEST = null; // Mais uma vez, outro tipo
}
</code></pre>

<p>Ao acessar a constante <code>TEST</code> de algum objeto do tipo <code>InterfaceTeste</code>, não havia nenhuma garantia que seu tipo sempre seria <code>string</code>. Com o PHP 8.3, o seguinte é possível:</p>

<pre><code class="php">interface InterfaceTeste {
    const string TEST = "Test";
}

class ClasseBase implements InterfaceTeste {
    const array TEST = []; // Isso falharia, pois muda o tipo da constante
}
</code></pre>

<h2 id="retorno-nulo-em-ffi">Retorno nulo em FFI</h2>

<p>Ao chamar uma função que não retorna nada, ou seja, <code>void</code>, via <code>FFI</code>, o PHP retornava um tipo específico chamado <code>FFI\CData</code> com o valor <code>void</code>. Agora, assim como em uma função PHP com o retorno <code>void</code>, nós receberemos <code>null</code> dessa função. Exemplo:</p>

<pre><code class="php">$ffi = FFI::cdef(
    "void free(void *ptr);",
    "libc.so.6"
);
// Até o PHP 8.2, isso retornaria `FFI\CData`, agora retorna `null`
$ffi-&gt;free(/* ponteiro*/);
</code></pre>

<h2 id="atributo-%60%23%5Coverride%60-para-sobrescrita-de-m%C3%A9todos">Atributo <code>#[\Override]</code> para sobrescrita de métodos</h2>

<p>Um novo atributo chega ao PHP 8.3. O atributo <code>#[Override]</code> permite que o código deixe claro que o método anotado com ele está sobrescrevendo um método da classe base, ou seja, caso haja alguma inconsistência na herança (como nome do método escrito errado) um erro de compilação será exibido.</p>

<p>Isso permite encontrar erros como o seguinte:</p>

<pre><code class="php">&lt;?php
class Conta
{
    public function saca(int $valor): void { /* implementação */ }
}

class ContaCorrente
{
    public function sacar(int $valor): void { /* implementação modificada */ }
}
</code></pre>

<p>O código acima possui um erro sutil no nome do método. Ao chamar <code>(new ContaCorrente())-&gt;saca($valor)</code>, embora a intenção seja chamar o método da classe <code>ContaCorrente</code> que sobrescreve o método da classe <code>Conta</code>, nós na verdade estamos chamando o método da classe <code>Conta</code> mesmo. Esse novo atributo nos permite descobrir esse erro com mais facilidade, exibindo uma mensagem de erro bastante clara:</p>

<pre><code class="php">&lt;?php
class Conta
{
    public function saca(int $valor): void { /* implementação */ }
}

class ContaCorrente
{
    #[Override]
    public function sacar(int $valor): void { /* implementação modificada */ }
}
</code></pre>

<p>Isso geraria o seguinte erro:</p>

<blockquote>
  <p>Fatal error: ContaCorrente::sacar() has #[\Override] attribute, but no matching parent method exists</p>
</blockquote>

<p>Essa é mais uma novidade do PHP 8.3 sobre a qual eu gravei um vídeo específico em meu canal do YouTube. Aqui você pode conferí-lo:</p>

<p><lite-youtube videoid="OO2fMqTAwZE">
    <a href="https://youtube.com/watch?v=OO2fMqTAwZE" class="lty-playbtn" title="Reproduzir vídeo">
        <span class="lyt-visually-hidden">
            Novidades do PHP 8.3 - Novo atributo (Override) para sobrescrita de métodos | Dias de Dev
        </span>
    </a>
</lite-youtube></p>

<h2 id="exce%C3%A7%C3%B5es-de-datetime-mais-adequadas-e-espec%C3%ADficas">Exceções de DateTime mais adequadas e específicas</h2>

<p>Algumas novas classes de exceção são introduzidas no PHP 8.3. Se tratando de <code>DateTime</code>, essas são as novas exceções:</p>

<ul>
<li><code>DateException</code>

<ul>
<li><code>DateInvalidOperationException</code></li>
<li><code>DateInvalidTimezoneException</code></li>
<li><code>DateMalformedIntervalStringException</code></li>
<li><code>DateMalformedPeriodStringException</code></li>
<li><code>DateMalformedStringException</code></li>
</ul></li>
<li><code>DateError</code>

<ul>
<li><code>DateObjectError</code></li>
<li><code>DateRangeError</code></li>
</ul></li>
</ul>

<p>Com isso, algumas exceções lançadas anteriormente ao instanciar objetos do tipo <code>DateTime</code>, <code>DateTimeImmutable</code>, <code>DateInterval</code> e <code>DatePeriod</code> podem ser diferentes agora. Um exemplo:</p>

<pre><code class="php">// Até o PHP 8.2, uma exceção do tipo `Exception` seria lançada
// A partir do 8.3, `DateMalformedStringException` será lançada
new DateTime('data inválida');
</code></pre>

<p>Essa é uma <em>RFC</em> simples, mas com um grande número de modificações. Se quiser saber mais sobre cada caso que pode lançar uma das novas exceções, você pode conferir a <a href="https://wiki.php.net/rfc/datetime-exceptions">página da <em>RFC</em></a>.</p>

<h2 id="nova-fun%C3%A7%C3%A3o-%60json_validate%60">Nova função <code>json_validate</code></h2>

<p>Em alguns cenários nós precisamos garantir que uma <em>string</em> é um <em>json</em> válido, mas não necessariamente precisamos realizar a transformação dessa <em>string</em> em um objeto ou <em>array</em> em PHP. Se nós precisamos armazenar no banco de dados um <em>json</em> recebido na requisição, por exemplo, não há necessidade de realizar todo o trabalho de transformar esse <em>json</em> com a função <code>json_decode</code>.</p>

<p>Porém, até o PHP 8.2, a única forma de descobrirmos se uma <em>string</em> é um <em>json</em> válido em PHP era através da função <code>json_decode</code>. Esse desperdício de recursos foi resolvido no PHP 8.3 com a chegada da função <code>json_validate</code>.</p>

<p>Essa nova função garante que o <em>json</em> é válido, mas sem precisar alocar memória para salvar seu conteúdo transformado já que ela simplesmente retorna um booleano.</p>

<p>Eu gravei um vídeo curto no YouTube (no formato de <em>shorts</em>) falando sobre essa nova função. Você pode conferir aqui:</p>

<p><lite-youtube videoid="7rnKavIf67w">
    <a href="https://youtube.com/watch?v=7rnKavIf67w" class="lty-playbtn" title="Reproduzir vídeo">
        <span class="lyt-visually-hidden">
            Novidades do PHP 8.3: Nova função json_validate | Dias de Dev #shorts
        </span>
    </a>
</lite-youtube></p>

<h2 id="comando-%60php--l%60-agora-suporta-m%C3%BAltiplos-arquivos">Comando <code>php -l</code> agora suporta múltiplos arquivos</h2>

<p>Um comando muito útil é o <code>php -l</code> que permite verificar se um arquivo possui algum erro de sintaxe. Até a versão 8.2 do PHP apenas um arquivo podia ser analisado por vez. Agora, a partir do PHP 8.3, nós podemos passar diversos arquivos para o <code>php -l</code> analisar. Exemplo:</p>

<pre><code class="shell">php -l arquivo1.php arquivo2.php
</code></pre>

<p>O comando exibirá, caso nenhum dos arquivos possua erros de sintaxe:</p>

<blockquote>
  <p>No syntax errors detected in arquivo1.php</p>
  
  <p>No syntax errors detected in arquivo2.php</p>
</blockquote>

<h2 id="fun%C3%A7%C3%B5es-array_sum-e-array_product-mais-consistentes">Funções array_sum e array_product mais consistentes</h2>

<p>As funções <code>array_sum</code> e <code>array_product</code> possuiam um comportamento menos previsível quando valores não numéricos eram encontrados nos arrays a serem processados. Essa novidade traz uma maior consistência e previsibilidade para seu comportamento.</p>

<p>Por exemplo:</p>

<pre><code class="php">$input = [true, STDERR, new stdClass(), []];
var_dump(array_sum($input));
var_dump(array_product($input));
</code></pre>

<p>Tanto até o PHP 8.2 quanto no PHP 8.3, os resultados serão 4 e 3, porém no PHP 8.3 diversos alertas serão exibidos informando que não é possível realizar operações matemáticas em <code>resource</code>, em <code>stdClass</code> e em <code>array</code> (<code>true</code> vira 1 em operações matemáticas no PHP e isso não muda nessa versão).</p>

<p>Isso faz com que nós sejamos notificados pela aplicação caso operações matemáticas estejam sendo realizadas onde não deveriam.</p>

<p>Há mais pontos de melhoria trazidos por essa <em>RFC</em> e por isso eu também tenho um vídeo completo sobre ela:</p>

<p><lite-youtube videoid="cpJAwte1xZU">
    <a href="https://youtube.com/watch?v=cpJAwte1xZU" class="lty-playbtn" title="Reproduzir vídeo">
        <span class="lyt-visually-hidden">
            Novidades do PHP 8.3 - Funções array_sum e array_product mais consistentes | Dias de Dev
        </span>
    </a>
</lite-youtube></p>

<h2 id="mais-novidades">Mais novidades</h2>

<p>Você já deve ter reparado que esse post começou a ficar bem grande, não é mesmo? O PHP 8.3 realmente está trazendo algumas novidades bem interessantes e nesse post eu quis destacar algumas delas.</p>

<p>Mas se você quiser saber sobre <strong>todas</strong> as novidades que o PHP 8.3 traz, pode conferir a <a href="https://wiki.php.net/rfc#php_83">página oficial das <em>RFCs</em></a> ou conferir a seguinte lista:</p>

<ul>
<li><a href="https://wiki.php.net/rfc/deprecations_php_8_3">Descontinuações do PHP 8.3</a></li>
<li><a href="https://wiki.php.net/rfc/saner-inc-dec-operators">Modificações nos operadores de incremento e decremento</a></li>
<li><a href="https://wiki.php.net/rfc/arbitrary_static_variable_initializers">Possibilidade de usar expressões em variáveis estáticas</a></li>
<li><a href="https://wiki.php.net/rfc/unserialize_warn_on_trailing_data">Aviso quando <code>unserialize()</code> encontrar dados remanescentes</a></li>
<li><a href="https://www.youtube.com/watch?v=h3dZlJrpvi0">Acesso dinâmico a constantes de classes</a></li>
<li><a href="https://wiki.php.net/rfc/improve_unserialize_error_handling">Melhoria de tratativa de erros da função <code>unserialize()</code></a></li>
<li><a href="https://wiki.php.net/rfc/assert-string-eval-cleanup">Descontinuações relacionadas às funções de <code>assert</code></a></li>
<li><a href="https://wiki.php.net/rfc/mb_str_pad">Nova função mb_str_pad</a></li>
<li><a href="https://wiki.php.net/rfc/proper-range-semantics">Melhor definição da semântica da função <code>range()</code></a></li>
<li><a href="https://wiki.php.net/rfc/randomizer_additions">Adições à extensão de aleatoriedade (<code>Randomizer</code>)</a></li>
<li><a href="https://wiki.php.net/rfc/sqlite3_exceptions">Utilizar exceções por padrão na extensão <code>SQLite3</code></a></li>
<li><a href="https://wiki.php.net/rfc/deprecate_functions_with_overloaded_signatures">Descontinuar funções com sobrecarga</a></li>
</ul>

<p>E se você quiser aprender mais sobre PHP e suas funcionalidades, vou deixar aqui um <a href="https://tidd.ly/4d42Myb">cupom de desconto para a Alura</a>, onde eu tenho diversos cursos sobre PHP, dentre outros assuntos.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Explorando Métodos Mágicos no PHP: Conceitos e Exemplos Práticos]]></title>
            <link href="https://dias.dev/2023-08-11-metodos-magicos-php/"/>
            <updated>2023-08-11T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-08-11-metodos-magicos-php/</id>
            <content type="html"><![CDATA[<p>Os métodos mágicos no PHP são métodos "especiais" que são invocadas implicitamente quando certas ações ocorrem. Neste post, exploraremos esses métodos, como eles funcionam e como podem ser úteis.</p>

<h3 id="m%C3%A9todos-m%C3%A1gicos%3A-uma-vis%C3%A3o-geral">Métodos mágicos: Uma visão geral</h3>

<p>PHP é uma linguagem de programação que suporta, dentre outros, o paradigma de programação orientada a objetos. Sendo assim, podemos definir métodos dentro das nossas classes, ou seja, funções que operam no contexto de um objeto. Métodos mágicos são aqueles que podemos definir em nosso código e são acionados automaticamente pelo PHP em situações específicas.</p>

<p>Alguns exemplos de quando os métodos mágicos podem ser acionados incluem tentativas de acesso a membros inexistentes ou inacessíveis de uma classe, conversões de objetos e verificações especiais.</p>

<h2 id="exemplo-pr%C3%A1tico">Exemplo prático</h2>

<p>Um exemplo claro dos métodos mágicos em ação é o caso do framework Laravel. Considere uma classe de modelo (<em>Model</em>) que lida com a persistência de um usuário:</p>

<pre><code class="php">&lt;?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{ }
</code></pre>

<p>Apesar de não definir nenhuma propriedade explicitamente, podemos atribuir valores a propriedades como se elas existissem:</p>

<pre><code class="php">&lt;?php

use App\Models\User;

$user = new User();
$user-&gt;name = 'Vinicius Dias';
$user-&gt;email = 'email@example.com';
$user-&gt;save();
</code></pre>

<p>O método <code>save</code> é entendido como parte da classe base <code>Model</code>, mas e quanto às propriedades? Para cenários como esse, os métodos mágicos foram concebidos.</p>

<h2 id="implementa%C3%A7%C3%A3o-de-m%C3%A9todos-m%C3%A1gicos">Implementação de métodos mágicos</h2>

<p>O nome de todo método mágico no PHP começa com dois underscores (<code>__</code>). Por exemplo, o método <code>__set</code> é invocado quando tentamos atribuir um valor a uma propriedade inexistente ou inacessível. Ele recebe o nome da propriedade e o valor como parâmetros:</p>

<pre><code class="php">&lt;?php

class NossaModel
{
    /**
     * @var array&lt;string, mixed&gt; Array associativo contendo todos os valores que definirmos
     */
    private array $atributos;

    /**
     * @param string $name Nome da propriedade inacessível que estamos tentando definir
     * @param mixed $value Valor que estamos tentando atribuir a essa propriedade
     * @return void
     */
    public function __set(string $name, mixed $value): void
    {
        /*
         * Aqui, se fizermos $model-&gt;teste = 'Valor', criaremos a chave 'teste'
         * na propriedade $atributos com o valor 'Valor'
         */
        $this-&gt;atributos[$name] = $value;
    }
}
</code></pre>

<p>Repare que o código que escrevemos no método é código PHP como qualquer outro. Ali nós poderíamos realizar qualquer tipo de lógica.</p>

<h3 id="como-acessar-esse-valor%3F">Como acessar esse valor?</h3>

<p>Aprendemos a definir um valor a partir de uma propriedade inexistente, mas se tentarmos ler esse valor, receberemos um erro. O código a seguir, por exemplo, falha:</p>

<pre><code class="php">$teste = new NossaModel();
$teste-&gt;nome = 'Vinicius';

/*
 * Na linha a seguir, o retorno será nulo e um _Warning_ será emitido
 * dizendo que a propriedade NossaModel::$nome não existe.
 */
echo $teste-&gt;nome;
</code></pre>

<p>Para escrever em propriedades inexistentes, usamos o <code>__set</code>. Já para ler de propriedades inexistentes ou inacessíveis, utilizamos o método <code>__get</code>. Então poderíamos ter o seguinte método na classe <code>NossaModel</code>:</p>

<pre><code class="php">/**
 * @param string $name Nome da propriedade inexistente que estamos tentando ler
 * @return mixed Aqui devemos retornar o valor que corresponderá a essa propriedade 
 */
public function __get(string $name): mixed
{
    // O valor retornado pelo método __get é utilizado onde tentamos acessar a propriedade 
    return $this-&gt;atributos[$name];
}
</code></pre>

<p>Com isso, o código a seguir funcionaria sem problemas:</p>

<pre><code class="php">$teste = new NossaModel();
// Chamada implícita a $teste-&gt;__set('nome', 'Vinicius');
$teste-&gt;nome = 'Vinicius';

// Chamada implícita a $teste-&gt;__get('nome'), que vai retornar 'Vinicius'
echo $teste-&gt;nome;
</code></pre>

<h2 id="mais-m%C3%A9todos">Mais métodos</h2>

<p>Até aqui nós citamos apenas 2 métodos mágicos, mas o PHP fornece diversos outros. Vou deixar a seguir uma lista deles:</p>

<h3 id="construtor-e-destrutor">Construtor e destrutor</h3>

<p>O método construtor, chamado de <code>__construct</code>, é executado quando criamos um novo objeto (utilizando <code>new</code>). Normalmente utilizamos o método construtor para receber dependências e inicializar as propriedades.</p>

<p>Já o método destrutor, <code>__destruct</code>, é executado quando um objeto sai de escopo ou quando o objeto é passado para a função <code>unset</code>. Normalmente ele é utilizado para liberar recursos que tenham sido alocados no construtor, como fechar arquivos, conexões, etc. Com a natureza <em>stateless</em> do PHP, esse método não é tão utilizado.</p>

<h3 id="convers%C3%B5es">Conversões</h3>

<p>Em alguns cenários nós podemos querer utilizar nossos objetos como um tipo diferente. Se quisermos usar nosso objeto como uma string, por exemplo, podemos utilizar o método <code>__toString</code>. O que nós retornarmos nesse método é utilizado se nosso objeto for convertido para string de forma implícita ou explícita. Objetos de resposta HTTP, por exemplo, geralmente implementam esse método retornando o corpo da resposta.</p>

<pre><code class="php">&lt;?php

class Response
{
    private string $body;
    // Outras propriedades

    public function __toString() : string
    {
        return $this-&gt;body;
    }
}

$response = new Response();
// Definição dos valores

echo $response; // Isso usa o objeto como string, logo, chama o __toString
</code></pre>

<p>Há também casos onde queremos utilizar nosso objeto como se ele fosse uma função. Para isso existe o método <code>__invoke</code>. Se nós passarmos nosso objeto por parâmetro em algum lugar que espera um <code>callable</code>, o método <code>__invoke</code> será executado. Exemplo:</p>

<pre><code class="php">&lt;?php

class ControllerDeExemplo
{
    public function __invoke(int $parametro1, string $parametro2): void
    {
        // Execução de exemplo
    }
}

$controller = new ControllerDeExemplo();

$controller(1, 'Teste'); // Isso executará o método __invoke
</code></pre>

<h3 id="chamada-de-m%C3%A9todos">Chamada de métodos</h3>

<p>Assim como nós podemos acessar propriedades inexistentes (ou inacessíveis) com métodos mágicos, o mesmo serve para métodos. Se você tentar chamar um método não existente de um objeto, o método <code>__call</code> será executado, recebendo o nome do método que tentou ser executado e todos os seus parâmetros. Já o <code>__callStatic</code> funciona da mesma forma, mas caso um método <strong>estático</strong> inexistente seja chamado a partir de uma classe.</p>

<pre><code class="php">class Exemplo
{
    public function __call(string $name, array $arguments): mixed
    {
        /*
         * $name possui o nome do método inexistente que foi executado,
         * enquanto $arguments possui todos os parâmetros que foram passados para esse método
         */
    }

    public static function __callStatic(string $name, array $arguments): mixed
    {
        // Equivalente estático ao __call
    }
}

// Chama implicitamente Exemplo::__callStatic('qualquerCoisa', [1, 2]):
Exemplo::qualquerCoisa(1, 2);

$objeto = new Exemplo();

// Chama implicitamente $objeto-&gt;__call('qualquerCoisa', [1, 2]):
$objeto-&gt;qualquerCoisa(1, 2);
</code></pre>

<h3 id="restante-dos-m%C3%A9todos">Restante dos métodos</h3>

<p>Para que esse post não fique ainda maior, vou deixar a seguir uma lista dos demais métodos mágicos com uma breve descrição, mas caso você queira ver mais exemplos e detalhes, pode conferir a <a href="https://www.php.net/manual/en/language.oop5.magic.php">documentação do PHP</a>.</p>

<ul>
<li><code>__isset</code>: Método executado caso passemos alguma propriedade inacessível do nosso objeto para a função <code>isset</code> ou <code>empty</code>;</li>
<li><code>__unset</code>: Método executado caso passemos alguma propriedade inacessível do nosso objeto para a função <code>unset</code>;</li>
<li><code>__sleep</code>: Ao chamar a função <code>serialize</code> passando nosso objeto, esse método é executado <strong>antes</strong> da serialização. Seu retorno deve ser um array contendo os nomes das propriedades do objeto em questão que serão serializadas. Normalmente é utilizado para remover propriedades que não devem ser serializadas com conexões com o banco, arquivos abertos, etc;</li>
<li><code>__wakeup</code>: Esse método não recebe parâmetros e é executado <strong>após</strong> um dado ser desserializado e o objeto ser criado. Esse método geralmente reconstrói os recursos como conexões com o banco;</li>
<li><code>__serialize</code>: Similar ao <code>__sleep</code>. Se ambos estiverem definidos, apenas <code>__serialize</code> é chamado e <code>__sleep</code> é ignorado. A diferença é que o <code>__serialize</code> deve retornar um array associativo que será serializado ao invés de retornar os nomes das propriedades do objeto;</li>
<li><code>__unserialize</code>: Similar ao <code>__wakeup</code>. Se ambos estiverem definidos, apenas <code>__unserialize</code> é chamado e <code>__wakeup</code> é ignorado. <code>__unserialize</code> recebe por parâmetro o array que foi serializado e com isso, deve reconstruir o objeto;</li>
<li><code>static __set_state</code>: Esse método é o mais raro. Ele é utilizado para criar um objeto da classe em questão a partir da função <code>var_export</code>;</li>
<li><code>__clone</code>: Método chamado quando um clone de um objeto é criado. <code>$this</code> nesse método vai se referir ao novo objeto criado. Normalmente esse método é definido para evitar <em>shallow copies</em> e realizar os clones de todas as propriedades também;</li>
<li><code>__debugInfo</code>: O retorno desse método deve conter os dados que serão exibidos pela função <code>var_dump</code>. Geralmente é um array associativo;</li>
</ul>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>O PHP possui um grande número de métodos mágicos. Alguns são bastante fáceis de entender como <code>__get</code>, <code>__set</code> e <code>__call</code>, enquanto outros são mais confusos como as diferenças entre <code>__sleep</code> e <code>__serialize</code>. Há ainda aqueles bem pouco usados como o <code>__set_state</code>.</p>

<p>Lembrar de todos os métodos (e suas assinaturas) e o que cada um deles faz não é necessário, mas é importante saber da existência deles para saber o que pesquisar quando for necessário.</p>

<p>Se quiser aprender mais sobre PHP e sobre tecnologia em geral, vou deixar aqui um <a href="https://tidd.ly/4d42Myb">cupom de 10% de desconto na Alura</a>, plataforma onde eu gravei inúmeros cursos.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Como remover acentos de palavras com PHP]]></title>
            <link href="https://dias.dev/2023-08-01-como-remover-acentos-de-palavras-com-php/"/>
            <updated>2023-08-01T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-08-01-como-remover-acentos-de-palavras-com-php/</id>
            <content type="html"><![CDATA[<p><em>Edit: <a href="https://www.linkedin.com/feed/update/urn:li:activity:7092531957842026499?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A7092531957842026499%2C7092591873462038528%29">Neste comentário</a> o Wanderson me apontou outra solução para resolver o mesmo problema, então estou adicionando-a ao início do post.</em></p>

<h2 id="extens%C3%A3o-iconv">Extensão iconv</h2>

<pre><code class="php">&lt;?php

$string = 'Ãéïòû';
echo iconv('UTF-8', 'ASCII//TRANSLIT', $string); // Exibe: Aeiou
</code></pre>

<p>O código PHP acima remove os acentos, logo, o texto <code>Ãéïòû</code> vai se tornar <code>Aeiou</code>. Esse trabalho é realizado pela <a href="/2022-02-13-extensoes-php/">extensão</a> <code>iconv</code> que vem instalada por padrão no PHP. Ela permite a conversão entre <em><a href="/2021-08-24-charsets-e-encodings-como-strings-funcionam/">encodings</a></em>.</p>

<p>Ao converter uma string para <em>ASCII</em>, nós podemos escolher ignorar os caracteres não existentes nesse <em>charset</em> ou realizar uma transliteração (mapeamento) dos caracteres que não fazem parte da tabela para o mais próximo possível. Para isso, adicionamos o sufixo <code>//TRANSLIT</code> ao segundo parâmetro. Isso transforma, por exemplo, o caractere <code>Ã</code> em <code>A</code>.</p>

<p>Essa abordagem vai funcionar na maioria dos cenários, mas há algumas observações que devem ser consideradas.</p>

<h3 id="locale">Locale</h3>

<p>A conversão com <code>iconv</code> não vai funcionar caso a categoria <code>LC_CTYPE</code> do <code>locale</code> esteja definida como <code>C</code> ou <code>POSIX</code>.</p>

<p>Exemplo:</p>

<pre><code class="php">&lt;?php

setlocale(LC_CTYPE, 'POSIX');
echo iconv('UTF-8', 'ASCII//TRANSLIT', 'Ãéïòû'); // Exibe ?????
</code></pre>

<h3 id="implementa%C3%A7%C3%A3o-do-iconv">Implementação do iconv</h3>

<p>Outro problema é que o sufixo <code>//TRANSLIT</code> tem seu funcionamento dependente da implementação do <code>iconv</code> que seu sistema operacional possui. Algumas implementações são conhecidas por ignorar <code>//TRANSLIT</code>, então a conversão provavelmente falhará.</p>

<p>Para esses cenários uma de suas opções é instalar outra implementação do <code>iconv</code>. Você pode verificar qual a implementação do seu sistema operacional lendo o conteúdo da constante <code>ICONV_IMPL</code>. A implementação <code>glibc</code> é segura e funciona conforme exemplificado nesse post.</p>

<h3 id="solu%C3%A7%C3%A3o">Solução</h3>

<p>Caso você, por algum motivo, não possa alterar o <code>locale</code> em seu servidor e o padrão for <code>C</code> ou <code>POSIX</code>, a solução descrita não é válida para seu caso. Se sua implementação do <code>iconv</code> no sistema operacional for uma incompatível com <code>//TRANSLIT</code> e você não puder ou preferir não instalar outra implementação, essa dica também não foi para você.</p>

<p>Uma solução para os problemas previamente citados é utilizar outra abordagem, com outra extensão. Para estes raros cenários, deixo a seguir o conteúdo original desse post, onde mostro como utilizar a normalização de strings com PHP para remover acentos.</p>

<h2 id="post-original">Post original</h2>

<p>Remover acentos de palavras usando PHP é uma tarefa bastante comum, principalmente para gerar <em>slugs</em> ou links amigáveis. Nesse texto nós vamos aprender a utilizar a extensão <em>intl</em> para realizar essa tarefa com 2 simples linhas de código.</p>

<h3 id="tl%3Bdr-me-mostre-logo-o-c%C3%B3digo">TL;DR Me mostre logo o código</h3>

<pre><code class="php">&lt;?php

$string = 'Ãéïòû';

$normalized = Normalizer::normalize($string, Normalizer::NFD);
echo preg_replace('/[\x{0300}-\x{036F}]/u', '', $normalized); // Exibe: Aeiou

</code></pre>

<p>O código PHP acima remove os acentos, logo, o texto <code>Ãéïòû</code> vai se tornar <code>Aeiou</code>. Agora vamos entender o que o código faz.</p>

<h2 id="normaliza%C3%A7%C3%A3o-de-texto">Normalização de texto</h2>

<p>A primeira parte desse simples algoritmo consiste em <strong>normalizar</strong> o texto. Normalizar um texto consiste em transformá-lo de alguma forma pré-determinada, seguindo algumas normas ou regras.</p>

<p>O código acima pega a string <code>"Ãéïòû"</code> e a normaliza utilizando a forma de normalização D (<code>NFD</code>), conhecida também como decomposição canônica (<em>Canonical Decomposition</em>). Essa regra consiste em separar os caracteres de acentuação dos demais, ou seja, caracteres como crase (&#96;) ou til (~) são separados das letras. O caractere <code>Ã</code>, por exemplo, se torna <code>A~</code>.</p>

<p>Essa forma de normalização foi definida e nomeada pelo <a href="/2021-08-24-charsets-e-encodings-como-strings-funcionam/"><em>Unicode Consortium</em></a>, mas não é a única. Você pode conferir mais detalhes sobre cada uma das "regras" no site oficial: <a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>.</p>

<h3 id="extens%C3%A3o-php">Extensão PHP</h3>

<p>Tendo entendido o que é normalizar um texto, como é possível atingir esse objetivo com PHP? Através de uma <a href="/2022-02-13-extensoes-php/">extensão</a> externa chamada <code>intl</code>.</p>

<p>Essa extensão fornece acesso a uma biblioteca famosa chamada <em>ICU (International Components for Unicode)</em>, que traz diversas operações referentes a <em>locale</em>. O termo <em>locale</em> em inglês não tem uma boa tradução (pelo menos eu não conheço), mas basicamente se refere a informações como formatos de data e hora, moedas, textos, etc. Repare que não é apenas relacionado ao idioma, mas tudo que envolve formatos internacionais.</p>

<p>A extensão <code>intl</code> traz, dentre várias outras, a classe <code>Normalizer</code> que tem como único propósito realizar a normalização de textos. Com isso, o código a seguir separa cada caractere de seu respectivo acento, caso haja algum:</p>

<pre><code class="php">$normalized = Normalizer::normalize('Ãéïòû', Normalizer::NFD);
</code></pre>

<p>Isso vai devolver uma string com o conteúdo semelhante ao seguinte: <code>A~e´i¨o`u^</code>. "Semelhante" porque os caracteres individuais e separados de acentos (como o <code>^</code>) não são os mesmos que vemos quando são adicionados a uma letra, então o real caractere não vai ser visível de forma individual ao tentar exibir a string resultante. Mas nós não queremos exibir a string normalizada, e sim manipulá-la. E é justamente sobre essa manipulação que vamos falar agora.</p>

<h2 id="express%C3%A3o-regular">Expressão regular</h2>

<p>Após separar os caracteres de seus respectivos acentos, a tarefa de remover os acentos se torna bastante simples. Basta utilizarmos uma expressão regular (a temida <em>regex</em>) para remover qualquer caractere que seja um acento. Os caracteres com código <em>Unicode</em> entre U+0300 e U+036F são acentos, logo, podemos removê-los com o seguinte código:</p>

<pre><code class="php">preg_replace('/[\x{0300}-\x{036F}]/u', '', $normalized);
</code></pre>

<p>O modificador <code>/u</code>, ao final da <em>regex</em>, indica ao PHP que estamos trabalhando com UTF-8 nessa expressão regular, o que nos permite utilizar <code>\x</code>, que é o que nos dá o poder de identificar os caracteres <em>Unicode</em>.</p>

<p>Isso garante não haver alteração da string original, mantendo números, caracteres especiais, etc. Claro que você pode mudar a expressão regular para remover tudo que não sejam letras, números e espaços, por exemplo. O código ficaria assim:</p>

<pre><code class="php">preg_replace('/[^a-zA-Z0-9\s]/', '', $normalized);
</code></pre>

<p>O código acima é geralmente utilizado para gerar URLs amigáveis, ou os famosos <em>slugs</em>. Mas após entender o processo de normalização, modificar a <em>regex</em> para atingir objetivos diferentes e mais específicos se torna uma tarefa trivial.</p>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Embora seja uma tarefa bastante comum, remover acentos com PHP pode não parecer tão fácil quando uma rápida pesquisa é feita na internet. Diversas listas enormes de caracteres a serem substituídos são sugeridas, dentre outras práticas ainda mais "questionáveis".</p>

<p>O simples uso de uma extensão apropriada faz com que essa complexa tarefa seja imensamente facilitada. Recomendo acessar os links que deixei durante o post como referência para se aprofundar em cada um dos assuntos aqui abordados.</p>

<p>Já no link a seguir eu deixo um <a href="https://tidd.ly/4d42Myb">cupom de 10% de desconto</a> para você assinar a Alura, plataforma onde há cursos completos (alguns comigo, inclusive) sobre manipulação de strings (dentre vários outros assuntos de tecnologia).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Strings multibyte: o que são e por que você precisa da extensão mbstring do PHP]]></title>
            <link href="https://dias.dev/2023-03-21-strings-multibyte-php-mbstring/"/>
            <updated>2023-03-21T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-03-21-strings-multibyte-php-mbstring/</id>
            <content type="html"><![CDATA[<p><em>Strings multibyte</em> são textos que possuem alguns caracteres que demandam mais de um <em>byte</em> para serem representados. Há um post aqui no blog onde nós falamos sobre <a href="/2021-08-24-charsets-e-encodings-como-strings-funcionam/">Charsets e Encodings: Como strings funcionam</a>. Agora nós vamos entender como lidar com <em>strings multibyte</em> em PHP usando a <a href="/2022-02-13-extensoes-php/">extensão</a> <code>mbstring</code>.</p>

<h2 id="opera%C3%A7%C3%B5es-em-strings">Operações em strings</h2>

<p>Quando trabalhamos com textos, é bastante comum precisarmos realizar algumas operações. Transformar todas as letras em maiúsculas ou minúsculas, por exemplo, é uma operação corriqueira. Até operações mais simples como contar o número de caracteres podem nos trazer algumas dores de cabeça se estivermos trabalhando com <em>strings multibyte</em>.</p>

<p>Um exemplo bastante simples:</p>

<pre><code class="php">&lt;?php

echo strlen('Olá'); // Exibe 4
echo strtoupper('olá'); // Exibe "OLá"
</code></pre>

<h2 id="strings-multibyte">Strings multibyte</h2>

<p>Como foi exposto logo na introdução do post, uma <em>string multibyte</em> é um texto que possui caracteres que demandam mais de um <em>byte</em> para serem representados. Caracteres com acento são um ótimo exemplo desse cenário. É necessário mais de um <em>byte</em> para representá-los, já que em um único <em>byte</em> nós conseguimos representar apenas 256 caracteres, que são, não coincidentemente, os caracteres da tabela <em>ASCII</em>.</p>

<p>As funções padrão de <em>strings</em> do PHP lidam assumindo que cada caractere da <em>string</em> possui um <em>byte</em>, por isso a contagem de caracteres é inválida com <code>strlen</code> e por isso que <strong>funções como <code>strtoupper</code> ou <code>strtolower</code> não conseguem modificar os caracteres acentuados</strong>.</p>

<h2 id="extens%C3%A3o-mbstring">Extensão mbstring</h2>

<p>Como nós cotidianamente trabalhamos com <em>strings</em> que contenham caracteres fora da tabela <em>ASCII</em>, obviamente o PHP não nos deixaria desamparados nessa situação. Para realizar operações em <em>strings multibyte</em> nós podemos usar a extensão <code>mbstring</code>. Nós já falamos sobre <a href="/2022-02-13-extensoes-php/">extensões PHP</a> aqui no blog, então vou partir do princípio que você já possui familiaridade com o assunto.</p>

<p>A extensão <code>mbstring</code> nos fornece diversas funções que possibilitam a manipulação de <em>strings multibyte</em>, indo de operações simples como contar o número de caracteres de uma string até operações mais complexas como <strong>converter o encoding de uma string</strong>.</p>

<p>A maioria das funções "padrão" de <em>strings</em> do PHP possui uma contraparte na <code>mbstring</code>, sendo apenas prefixada com <code>mb_</code>. O exemplo de código anteriormente exposto que nos gerava o resultado inesperado poderia ser escrito da seguinte forma:</p>

<pre><code class="php">&lt;?php

echo mb_strlen('Olá'); // Exibe 3
echo mb_strtoupper('olá'); // Exibe "OLÁ"
</code></pre>

<p>Além disso, se eu possuo uma <em>string</em> que está no <em>encoding</em> <code>ISO-8859-1</code> ou <code>WINDOWS-1252</code>, eu posso converter facilmente para UTF-8 com o seguinte código:</p>

<pre><code class="php"><br />echo mb_convert_encoding('string em ISO-8859-1', 'UTF-8', 'ISO-8859-1');
</code></pre>

<h2 id="%60utf8_encode%60-e-%60utf8_decode%60"><code>utf8_encode</code> e <code>utf8_decode</code></h2>

<p>Quem me acompanha já sabe que as funções <code>utf8_encode</code> e <code>utf8_decode</code> serão marcadas como <strong>obsoletas</strong> no PHP 8.2. Quem ainda não sabia disso pode conferir o vídeo a seguir:</p>

<p><lite-youtube videoid="al47Lz_SWLc" style="background-image: url('https://i.ytimg.com/vi/al47Lz_SWLc/hqdefault.jpg');">
    <a href="https://youtube.com/watch?v=al47Lz_SWLc" class="lty-playbtn" title="Reproduzir vídeo">
        <span class="lyt-visually-hidden">Novidades do PHP 8.2: Descontinuação de utf8_encode e utf8_decode | Dias de Dev</span>
    </a>
</lite-youtube></p>

<p>Como foi explicado no vídeo, essas funções serão descontinuadas já que são confusas e o uso de <code>mbstring</code> é uma opção válida para chegar ao mesmo resultado. A seguir você pode conferir como seria realizada a conversão das <em>strings</em> sem as famosas funções de <code>utf8_</code>:</p>

<pre><code class="php">&lt;?php

// Equivalente a utf8_encode('string em ISO-8859-1');
echo mb_convert_encoding('string em ISO-8859-1', 'UTF-8', 'ISO-8859-1');

// Equivalente a utf8_decode('string em UTF-8');
echo mb_convert_encoding('string em UTF-8', 'ISO-8859-1', 'UTF-8');
</code></pre>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Tendo entendido o conceito de <em>strings multibyte</em>, fica bastante claro tanto o papel da extensão <code>mbstring</code> quanto vários problemas que nós já enfrentamos ao manipular caracteres acentuados, por exemplo.</p>

<p>Se você quiser aprender mais sobre manipulações de strings, encodings, charsets, PHP e mais assuntos relacionados a tecnologia, aqui está um <a href="https://tidd.ly/4d42Myb">cupom de desconto</a> para assinar a Alura, plataforma de cursos online onde eu sou o instrutor da maioria dos cursos de PHP.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Entenda o erro &quot;Cannot modify header information - headers already sent&quot; no PHP]]></title>
            <link href="https://dias.dev/2023-03-07-entenda-o-erro-cannot-modify-header-information-php/"/>
            <updated>2023-03-07T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-03-07-entenda-o-erro-cannot-modify-header-information-php/</id>
            <content type="html"><![CDATA[<p>O famoso erro do PHP com o texto "<em>Cannot modify header information - headers already sent</em>" acontece quando tentamos enviar um cabeçalho <em>HTTP</em> após já termos enviado alguma saída no corpo da resposta. Nesse post nós vamos entender o que isso tudo significa e como evitar esse problema em seu código.</p>

<h2 id="_http_"><em>HTTP</em></h2>

<p><em>HTTP (HyperText Transfer Protocol)</em> é o protocolo usado na internet, então sempre que você acessa um site usando seu navegador, por exemplo, <em>HTTP</em> está sendo usado.</p>

<p><em>HTTP</em> é um protocolo que segue uma arquitetura cliente-servidor, onde há duas partes na comunicação. De forma super simplificada: você, usando seu navegador, é o cliente. O site que você acessa é o servidor.</p>

<p>Esse protocolo define mensagens de requisição (<em>request</em>) e resposta (<em>response</em>). Quando você acessa um site, seu navegador faz uma requisição para o servidor, que processa esse pedido e devolve uma resposta. Essas mensagens são divididas em duas grandes partes: <strong>cabeçalhos</strong> e <strong>corpo</strong>.</p>

<p>O corpo de uma resposta, por exemplo, é o conteúdo que você vê na tela, enquanto cabeçalhos possuem informações adicionais como <a href="/2022-09-27-cookies-e-seguranca">cookies</a>, informações de redirecionamento, etc.</p>

<p>Esse é um resumo bem conciso do protocolo <em>HTTP</em> e de <strong>como a internet funciona</strong>. Ainda sobre esse assunto, caso você tenha alguma dúvida ou queira entender melhor, eu tenho um vídeo no YouTube. Você pode conferí-lo antes de continuar lendo esse post:</p>

<p><lite-youtube videoid="B2IWlnJ_dt0" style="background-image: url('https://i.ytimg.com/vi/B2IWlnJ_dt0/hqdefault.jpg');">
  <a href="https://youtube.com/watch?v=B2IWlnJ_dt0" class="lty-playbtn" title="Reproduzir vídeo">
    <span class="lyt-visually-hidden">Play Video: Como funciona a Web? - A internet por baixo dos panos | Dias de Dev
</span>
  </a>
</lite-youtube></p>

<h2 id="como-o-php-funciona">Como o PHP funciona</h2>

<p>Entendido como a <em>web</em> funciona, é hora de entender o que o <strong>PHP</strong> faz na <em>web</em>. Aqui no blog há um post sobre <a href="/2021-06-15-como-o-php-funciona-na-web">como o PHP funciona na Web</a> onde você pode entender como o <strong>PHP</strong> é executado, mas aqui vou resumir o que você precisa saber para entender o problema de "<em>Cannot modify header information - headers already sent</em>".</p>

<p>Quando você exibe algo em PHP, seja através de funções como <code>echo</code> ou até colocando <em>HTML</em> junto com seu PHP, esse conteúdo é enviado no corpo da resposta <em>HTTP</em> que o PHP gera. Isso tudo é feito de forma transparente para nós desenvolvedores.</p>

<p>Como foi citado no parágrafo anterior, uma resposta <em>HTTP</em> é dividida entre <strong>cabeçalhos</strong> e <strong>corpo</strong>, sendo que os cabeçalhos vêm antes do corpo. Sendo assim, para nós adicionarmos algo ao corpo da resposta com PHP, os cabeçalhos precisam ser montados e enviados antes.</p>

<p>Então quando você, em um sistema <em>Web</em> feito em PHP, executa um <code>echo</code>, por exemplo, os cabeçalhos da resposta <em>HTTP</em> são montados e enviados e depois o corpo é enviado com o conteúdo desse <code>echo</code>.</p>

<p>Existem também funções no PHP que podem enviar ou modificar cabeçalhos. Algumas dessas funções são:</p>

<ul>
<li><code>header</code></li>
<li><code>header_remove</code></li>
<li><code>session_start</code></li>
<li><code>setcookie</code></li>
<li>etc</li>
</ul>

<h2 id="entendendo-o-problema">Entendendo o problema</h2>

<p>Como foi dito logo na introdução desse <em>post</em>, o problema "<em>Cannot modify header information - headers already sent</em>" acontece quando tentamos enviar um cabeçalho <em>HTTP</em> após já termos enviado algo no corpo da resposta.</p>

<p>Isso quer dizer que esse erro acontece quando nós tentamos usar alguma função que adiciona ou modifica cabeçalhos <em>HTTP</em> quando algum conteúdo já foi exibido. Se você executar o seguinte código em um contexto <em>web</em>, verá o erro em questão:</p>

<pre><code class="php">&lt;?php

echo 'Corpo da resposta';

header('Location: /url-de-redirecionamento');
</code></pre>

<p>O que nós estamos tentando fazer é enviar o cabeçalho <code>Location</code>, mas o corpo da resposta já começou a ser enviado quando nós executamos <code>echo</code>, ou seja, os cabeçalhos já foram montados e enviados para o cliente.</p>

<h3 id="problema-acontecendo-mesmo-sem-echo-ou-html">Problema acontecendo mesmo sem echo ou HTML</h3>

<p>Você talvez esteja se perguntando o motivo de já ter se deparado com esse erro mesmo sem ter, antes de uma função <code>header</code>, por exemplo, nenhuma exibição de conteúdo. Sendo assim, teoricamente, nenhuma resposta deveria ter sido criada e os cabeçalhos ainda não teriam sido enviados.</p>

<p>O que acontece é que não é incomum que nós geremos uma resposta mesmo sem querer. Se deixarmos espaços em branco antes da <em>tag</em> de abertura do PHP (<code>&lt;?php</code>) ou após a <em>tag</em> de fechamento do PHP (<code>?&gt;</code>), esses espaços serão exibidos e com isso os cabeçalhos serão enviados. Outro caso <strong>muito comum</strong> é se nossa aplicação gerar algum aviso (os famosos <em>warnings</em> do PHP). Esses avisos sendo exibidos também geram uma resposta e com isso, os cabeçalhos são enviados.</p>

<h3 id="solu%C3%A7%C3%A3o">Solução</h3>

<p>Para que o erro não ocorra mais, você precisa se certificar que qualquer função que adiciona ou modifica cabeçalhos <em>HTTP</em> (como <code>header</code> ou <code>session_start</code>) seja executada antes que qualquer coisa seja exibida, mesmo que de forma acidental.</p>

<p>Para isso, você pode:</p>

<ol>
<li>Identificar e corrigir qualquer problema no código que gere algum erro ou aviso;</li>
<li>Mover as funções que adicionam ou modificam cabeçalhos <em>HTTP</em> para o início da execução de sua aplicação, antes de qualquer exibição no corpo da resposta;</li>
<li><a href="/2023-02-24-php-ini-conhecendo-as-configuracoes-do-php">Configurar o PHP</a> para não exibir os erros e avisos (Isso só deve ser feito em produção. Em ambiente de desenvolvimento precisamos ver e corrigir os avisos);</li>
<li>Evitar o uso da <em>tag</em> de fechamento do PHP (<code>?&gt;</code>) em arquivos que contenham apenas código PHP;</li>
<li>Garantir que não há espaços antes da <em>tag</em> de abertura (<code>&lt;?php</code>) ou depois da tag de fechamento (<code>?&gt;</code>) do PHP.</li>
<li>Controlar o <a href="/2020-11-03-wraper-de-streams-php"><em>output buffer</em></a> do PHP, caso se depare com um caso mais específico.</li>
</ol>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Um dos erros mais conhecidos do mundo PHP, embora assustador, não é tão difícil de resolver. Com esse post você deve ter as informações necessárias para não se deparar com ele novamente e para resolver o problema caso o encontre.</p>

<p>Caso queira se aprofundar e conhecer ainda mais nos estudos sobre PHP, aqui tem um <a href="https://tidd.ly/4d42Myb">cupom de desconto</a> para assinar a Alura, plataforma de cursos online onde eu sou o instrutor da maioria dos cursos de PHP.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHP.ini: Aprendendo a configurar o comportamento do PHP]]></title>
            <link href="https://dias.dev/2023-02-24-php-ini-conhecendo-as-configuracoes-do-php/"/>
            <updated>2023-02-24T00:00:00+00:00</updated>
            <id>https://dias.dev/2023-02-24-php-ini-conhecendo-as-configuracoes-do-php/</id>
            <content type="html"><![CDATA[<h2 id="o-que-%C3%A9-o-php.ini%3F">O que é o php.ini?</h2>

<p>O arquivo <code>php.ini</code> é o responsável por conter as configurações que afetam o comportamento do PHP onde ele for executado. O PHP lê as configurações deste arquivo sempre que um novo processo é iniciado.</p>

<h3 id="todas-as-configura%C3%A7%C3%B5es-em-um-%C3%BAnico-arquivo%3F">Todas as configurações em um único arquivo?</h3>

<p>Entendido (mesmo que por alto) o que é o <code>php.ini</code>, talvez você se pergunte: "mas todas as configurações do PHP vão ficar em um único arquivo? Esse arquivo vai ser gigante!".</p>

<p>Esse questionamento é muito válido e a resposta é: não. Não é necessário manter todas as configurações em um único arquivo. É possível ter em sua instalação do PHP um diretório configurado onde outros arquivos de configuração (no mesmo formato) serão buscados e carregados.</p>

<h3 id="onde-encontrar-o-php.ini%3F">Onde encontrar o php.ini?</h3>

<p>A localização do arquivo <code>php.ini</code> (e dos demais arquivos de configuração) pode variar dependendo do sistema operacional e da forma como o PHP foi instalado, mas há um simples comando para te mostrar essa informação: <code>php --ini</code>. Executando esse comando você terá uma saída semelhante a seguinte:</p>

<pre><code>Configuration File (php.ini) Path: /etc/php/8.2/cli
Loaded Configuration File:         /etc/php/8.2/cli/php.ini
Scan for additional .ini files in: /etc/php/8.2/cli/conf.d
Additional .ini files parsed:      /etc/php/8.2/cli/conf.d/10-opcache.ini,
/etc/php/8.2/cli/conf.d/10-pdo.ini,
</code></pre>

<p>Repare que no exemplo acima, o arquivo "principal" é o <code>php.ini</code> encontrado na pasta <code>/etc/php/8.2/cli</code>. Mas há também a definição (feita no momento da compilação do PHP) para buscar outros arquivos de configuração na pasta <code>/etc/php/8.2/cli/conf.d</code>. Lá estão os arquivos <code>10-opcache.ini</code> e <code>10-pdo.ini</code>.</p>

<h4 id="prioridade-de-carregamento">Prioridade de carregamento</h4>

<p>Você deve ter notado que os arquivos "extra" de configuração possuem um número como prefixo (<code>10-opcache.ini</code> e <code>10-pdo.ini</code>). Esse número <strong>não</strong> tem um significado especial para o PHP, mas nos permite ordenar os arquivos por prioridade. O PHP vai carregar os arquivos <code>.ini</code> do diretório configurado em ordem alfabetica, sendo assim, números são adicionados para nós podermos definir a prioridade de carregamento de cada arquivo. Quanto maior o número, "mais depois" ele será carregado, fazendo com que suas definições sejam aplicadas por último, sobrescrevendo as anteriores caso hajam configurações duplicadas.</p>

<h2 id="o-que-pode-ser-configurado-pelo-php.ini">O que pode ser configurado pelo php.ini</h2>

<p>Existem muitas configurações diferentes que podem ser definidas no arquivo <code>php.ini</code>. Algumas das configurações mais comuns incluem:</p>

<ul>
<li>Configurações de exibição de erros</li>
<li>Configurações de segurança</li>
<li>Configurações de desempenho</li>
<li>Configurações de extensões</li>
</ul>

<h3 id="exemplos">Exemplos</h3>

<p>O formato <code>.ini</code> é bastante simples e consiste em uma chave (o nome da configuração) e um valor (o valor da configuração) separados pelo sinal de igualdade (<code>=</code>). Além disso, é possível adicionar comentários colocando um ponto e vírgula (<code>;</code>) em sua frente.</p>

<p>Sendo assim, para termos um arquivo <code>php.ini</code> dizendo que todos os erros devem ser exibidos, habilitando a <a href="/2022-09-27-cookies-e-seguranca/">configuração <code>secure</code> do cookie de sessão</a>, tendo o <a href="https://youtube.com/watch?v=6vEspHqjrkI">opcache</a> habilitado e a <a href="/2022-02-13-extensoes-php/">extensão</a> <code>pdo_mysql</code> também habilitada, nós teríamos o seguinte:</p>

<pre><code class="ini">; comentário. O PHP não vai ler essa linha
error_erporting=E_ALL
display_errors=1
session.cookie_secure=1
extension=pdo_mysql
opcache.enable=1
</code></pre>

<h3 id="configura%C3%A7%C3%B5es-poss%C3%ADvels">Configurações possívels</h3>

<p>Você não precisa tentar memorizar a lista de configurações possíveis, pois isso está disponível na documentação do PHP. A documentação de cada <a href="/2022-02-13-extensoes-php/">extensão</a>, por exemplo, possui uma seção de configurações que mostra as possíveis configurações com a explicação de cada um de seus valores.</p>

<h3 id="mais-detalhes-do-formato-ini">Mais detalhes do formato ini</h3>

<p>Antes de finalizar, você também deve ter notado que em nosso exemplo, duas linhas possuem um ponto (<code>.</code>) no nome da configuração e duas linhas não. Geralmente as configurações de <a href="/2022-02-13-extensoes-php/">extensões</a> são nomeadas no formato <em>extensao.configuracao</em>, ou seja, a configuração <code>enable</code> da extensão <code>opcache</code> se torna <code>opcache.enable</code>. Já as configurações que não são de uma extensão do PHP não possuem esse ponto.</p>

<p>Um outro detalhe do formato <code>ini</code> são suas <em>Sections</em>. Uma seção é identificada por um nome rodeado por colchetes. Então se eu quiser organizar meu arquivo e nomear uma seção nele com todas as configurações relacionadas a <a href="https://youtube.com/watch?v=6vEspHqjrkI">opcache</a>, eu poderia ter o seguinte:</p>

<pre><code class="ini">[opcache]
opcache.enable=1
opcache.validate_timestamps=0
; demais configurações de opcache
</code></pre>

<p>Isso não vai ter nenhum significado especial para o PHP, mas nos permite deixar o arquivo mais organizado para nós lermos futuramente.</p>

<h4 id="se%C3%A7%C3%B5es-especiais-do-php.ini">Seções especiais do php.ini</h4>

<p>Entendido o conceito de seções do formato <code>ini</code>, há duas seções especiais que podemos ter em nosso <code>php.ini</code>, chamadas <code>HOST</code> e <code>PATH</code>. Elas são utilizadas para limitar configurações que serão carregadas em determinados endereços web (<code>HOST</code>) ou em determinados caminhos de arquivos (<code>PATH</code>).</p>

<p>Para exibir todos os erros apenas em processos que respondem as requisições em <code>dev.example.com</code>, por exemplo, eu poderia ter o seguinte:</p>

<pre><code class="ini">[HOST=dev.example.com]
error_reporting=E_ALL
display_errors=1
</code></pre>

<p>Caso eu queira desabilitar o <a href="https://youtube.com/watch?v=6vEspHqjrkI">opcache</a> no projeto executado na pasta <code>/meu/projeto</code>, eu posso ter o seguinte:</p>

<pre><code class="ini">[PATH=/meu/projeto]
opcache.enable=0
</code></pre>

<h2 id="fun%C3%A7%C3%A3o-%60ini_set%60">Função <code>ini_set</code></h2>

<p>Além dos arquivos <code>.ini</code>, também é possível realizar algumas configurações no código do PHP, que serão válidas apenas durante aquela execução do processo. Para, por exemplo, habilitar a exibição de erros somente durante a execução de um código, podemos fazer o seguinte:</p>

<pre><code class="php">ini_set('display_errors', true);
</code></pre>

<p>Na documentação de cada configuração é informado se é possível realizá-la através da função <code>ini_set</code> ou apenas a partir de arquivos de configuração.</p>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>Conhecer o <code>php.ini</code> é de suma importância para qualquer pessoa que vá trabalhar com PHP, seja como <em>dev</em> ou até em time de operações/sysadmin. Cada <a href="/2022-02-13-extensoes-php/">extensão</a> do PHP vai ter, em sua documentação, a lista de configurações possíveis. Sempre que você for utilizar uma extensão como <em>PDO</em>, <em>cURL</em> ou qualquer outra, analise as configurações possíveis para saber se há alguma possível otimização para seu caso.</p>

<p>Durante o artigo eu deixei alguns links, mas aproveito para deixar algumas referências novamente aqui:</p>

<ul>
<li>Post aqui no blog sobre Extensões PHP: <a href="/2022-02-13-extensoes-php/">https://dias.dev/2022-02-13-extensoes-php/</a></li>
<li>Vídeo no meu canal sobre <em>Opcache</em>: <a href="https://youtube.com/watch?v=6vEspHqjrkI">https://youtube.com/watch?v=6vEspHqjrkI</a></li>
<li>Documentação sobre as diretivas do <code>php.ini</code>: <a href="https://www.php.net/manual/en/ini.php">https://www.php.net/manual/en/ini.php</a></li>
<li>Cupom de desconto na Alura para você se aprofundar em PHP: <a href="https://tidd.ly/4d42Myb">Cupom de desconto</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Enviando e-mails com PHP: uma introdução à função mail e ao SMTP]]></title>
            <link href="https://dias.dev/2022-09-27-como-enviar-emails-com-php/"/>
            <updated>2022-09-27T00:00:00+00:00</updated>
            <id>https://dias.dev/2022-09-27-como-enviar-emails-com-php/</id>
            <content type="html"><![CDATA[<blockquote>
  <p>Disclaimer: <em>Esse post foi escrito pela inteligência artificial do <a href="https://chat.openai.com/chat">ChatGPT</a> contendo apenas poucas alterações feitas por mim (Vinicius)</em></p>
</blockquote>

<p>Enviar e-mails é uma tarefa comum em muitos aplicativos web, e o PHP oferece uma função nativa chamada <code>mail</code> que pode ser usada para enviar mensagens de e-mail de forma relativamente simples. No entanto, a função <code>mail</code> tem algumas limitações e pode não ser a opção mais adequada para todos os casos de uso. Neste post, vamos explorar como a função <code>mail</code> funciona e quando é adequada usá-la, além de introduzir o conceito de Simple Mail Transfer Protocol (SMTP) e apresentar algumas opções de bibliotecas de envio de e-mails como PHPMailer e Symfony Mailer.</p>

<h2 id="a-fun%C3%A7%C3%A3o-%60mail%60-do-php">A função <code>mail</code> do PHP</h2>

<p>A função <code>mail</code> do PHP é uma forma simples de enviar e-mails usando a linguagem. Ela é chamada da seguinte maneira:</p>

<pre><code class="php">mail($to, $subject, $message, $headers, $parameters);
</code></pre>

<p>Onde:</p>

<ul>
<li><code>$to</code> é o endereço de e-mail do destinatário</li>
<li><code>$subject</code> é o assunto da mensagem</li>
<li><code>$message</code> é o corpo da mensagem</li>
<li><code>$headers</code> são cabeçalhos adicionais que podem ser incluídos na mensagem, como o endereço de e-mail do remetente ou o tipo de conteúdo da mensagem</li>
<li><code>$parameters</code> são parâmetros adicionais que podem ser passados para a função</li>
</ul>

<p>A função retorna <code>true</code> se a mensagem for enviada com sucesso e <code>false</code> caso contrário.</p>

<h3 id="como-a-fun%C3%A7%C3%A3o-%60mail%60-funciona-por-baixo-dos-panos">Como a função <code>mail</code> funciona por baixo dos panos</h3>

<p>Quando você chama a função <code>mail</code> do PHP, ela usa o programa sendmail instalado no servidor para enviar a mensagem. Isso significa que, para que a função <code>mail</code> funcione, é necessário que o sendmail esteja configurado e funcionando corretamente no servidor. Além disso, o endereço de e-mail do remetente da mensagem precisa ser válido e o servidor precisa ter permissão para enviar e-mails em nome desse remetente.</p>

<h3 id="limita%C3%A7%C3%B5es-da-fun%C3%A7%C3%A3o-%60mail%60">Limitações da função <code>mail</code></h3>

<p>Apesar de ser uma opção conveniente para o envio de e-mails em alguns casos, a função <code>mail</code> do PHP tem algumas limitações que devem ser consideradas:</p>

<ul>
<li>Ela depende do sendmail, que precisa estar instalado e configurado corretamente no servidor. Isso pode ser um problema se você estiver hospedando o aplicativo em um serviço de nuvem ou em um servidor que não tenha o sendmail instalado.</li>
<li>Ela não oferece muito controle sobre o envio de e-mails. Por exemplo, não é possível definir um servidor SMTP personalizado ou adicionar anexos à mensagem.</li>
<li>Ela pode ter problemas de entrega de e-mails devido a problemas de configuração do sendmail ou de problemas de DNS.</li>
<li>Ela não é muito confiável em aplicativos de produção, pois pode ser facilmente falsificada e pode ser bloqueada por provedores de e-mail.</li>
</ul>

<p>Essas limitações podem ser contornadas usando bibliotecas de envio de e-mails como o PHPMailer ou o Symfony Mailer, que são discutidas no próximo tópico.</p>

<h2 id="o-que-%C3%A9-smtp">O que é SMTP</h2>

<p>SMTP (Simple Mail Transfer Protocol) é um protocolo usado para enviar e-mails através da internet. Ele é responsável por transferir mensagens de e-mail de um servidor para outro, e também pode ser usado para enviar mensagens de e-mail de um cliente para um servidor.</p>

<p>Quando você envia um e-mail usando um cliente de e-mail como o Microsoft Outlook ou o Gmail, o cliente se comunica com um servidor SMTP para enviar a mensagem. Esse servidor é responsável por encaminhar a mensagem para o servidor de e-mail do destinatário, que, por sua vez, entrega a mensagem ao cliente de e-mail do destinatário.</p>

<h2 id="pacotes-de-envio-de-e-mails">Pacotes de envio de e-mails</h2>

<p>Se você precisa de mais flexibilidade do que a função <code>mail</code> do PHP pode oferecer, existem algumas bibliotecas que podem ser usadas para enviar e-mails com PHP. Dois exemplos populares são o PHPMailer e o Symfony Mailer.</p>

<p>O PHPMailer é uma das bibliotecas de envio de e-mail mais famosas do ecossistema PHP. Esse componente de código aberto que oferece uma interface de alto nível para o envio de e-mails usando PHP. Ele suporta vários métodos de envio, incluindo SMTP, e permite que você faça coisas como adicionar anexos e usar templates de e-mail.</p>

<p>Um exemplo de código que envia um e-mail usando <code>PHPMailer</code> seria o seguinte:</p>

<pre><code class="php">&lt;?php

use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\SMTP;
use PHPMailer\PHPMailer\Exception;

$mail = new PHPMailer(exceptions: true);

try {
    $mail-&gt;isSMTP();

    // Configurações do servidor
    $mail-&gt;Host = 'smtp.example.com';
    $mail-&gt;SMTPAuth = true;
    $mail-&gt;Username = 'usuario@example.com';
    $mail-&gt;Password = 'senha-secreta';
    $mail-&gt;SMTPSecure = PHPMailer::ENCRYPTION_SMTPS;
    $mail-&gt;Port = 465;

    // Remetente e Destinatários
    $mail-&gt;setFrom('remetente@example.com', 'Nome do Remetente');
    $mail-&gt;addAddress('destinatario@example.net', 'Primeiro Destinatário');
    $mail-&gt;addAddress('destinatario2@example.com');
    $mail-&gt;addReplyTo('responder@example.com', 'Nome de para quem responder');
    $mail-&gt;addCC('cc@example.com');
    $mail-&gt;addBCC('bcc@example.com');

    // Anexos
    $mail-&gt;addAttachment('/var/tmp/arquivo.tar.gz');
    $mail-&gt;addAttachment('/tmp/imagem.jpg', 'novo-nome.jpg');

    // Conteúdo
    $mail-&gt;isHTML(true);
    $mail-&gt;Subject = 'Assunto aqui';
    $mail-&gt;Body = 'Esse é o corpo da mensagem em HTML &lt;b&gt;em negrito!&lt;/b&gt;';
    $mail-&gt;AltBody = 'Esse é o corpo da mensagem em "texto puro" para clientes que não suportam HTML';

    $mail-&gt;send();
} catch (Exception $exception) {
    echo "Erro ao enviar e-mail: {$mail-&gt;ErrorInfo}";
}
</code></pre>

<h2 id="conclus%C3%A3o%3A">Conclusão:</h2>

<p>Enviar e-mails com PHP é uma tarefa relativamente simples graças à função <code>mail</code> nativa da linguagem. No entanto, essa função tem algumas limitações e pode não ser a opção mais adequada para todos os casos de uso. Se você precisar de mais flexibilidade, pode usar bibliotecas como o PHPMailer ou o Symfony Mailer, que oferecem recursos avançados para o envio de e-mails.</p>

<p>Espero que este post tenha sido útil para você entender as opções disponíveis para enviar e-mails com PHP e escolher a opção mais adequada para o seu projeto.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Extensões PHP]]></title>
            <link href="https://dias.dev/2022-02-13-extensoes-php/"/>
            <updated>2022-02-13T00:00:00+00:00</updated>
            <id>https://dias.dev/2022-02-13-extensoes-php/</id>
            <content type="html"><![CDATA[<p>PHP é uma linguagem de programação que roda em uma máquina virtual chamada <em>Zend Engine</em>. Essa máquina
virtual é escrita em C e permite que nós escrevamos código em C para embutir funcionalidades no PHP. Assim funcionam as
extensões do PHP.</p>

<h2 id="o-que-s%C3%A3o-extens%C3%B5es-do-php%3F">O que são extensões do PHP?</h2>

<p>As extensões no PHP são códigos escritos em C que são, de certa forma, embutidos na linguagem, logo, se parecem com código
nativo. É possível criarmos novas funções, classes e até criar sintaxe nova na linguagem a partir de extensões.</p>

<p>Quem usa PHP no dia-a-dia com certeza usa alguma extensão. Alguns exemplos de extensões PHP bem comuns:</p>

<ul>
<li>PDO</li>
<li>Sessions</li>
<li>JSON</li>
<li>cURL</li>
</ul>

<h2 id="tipos-de-extens%C3%B5es">Tipos de extensões</h2>

<p>Além de existir um número enorme de extensões do PHP, existem também alguns tipos onde elas podem ser categorizadas.
Estes tipos são: <em>Core Extensions</em>, <em>Bundled Extensions</em>, <em>External Extensions</em> e <em>PECL Extensions</em>.</p>

<h3 id="core-extensions">Core Extensions</h3>

<p>As extensões <em>Core</em>, como o nome já diz, fazem parte do <em>core</em> (núcleo) do PHP. O PHP não existe sem elas e é impossível
ter uma instalação do PHP sem estas. Alguns exemplos deste tipo de extensões são: Arrays, Classes/Objects, Date/Time,
JSON, OPCache etc.</p>

<p>Estas extensões são mantidas pela própria equipe do PHP já que fazem parte da linguagem em si.</p>

<h3 id="bundled-extensions">Bundled Extensions</h3>

<p>As extensões empacotadas com o PHP, chamadas de <em>bundled extensions</em>, são extensões que já vêm junto com o PHP, mas é
possível escolher habilitá-las ou não em sua instalação. Estas extensões também são mantidas pela equipe do PHP já que
são empacotadas junto com o restante do código da linguagem.</p>

<p>Alguns exemplos de extensões deste tipo: PDO, GD, FFI, intl, Sessions etc.</p>

<h3 id="external-extensions">External Extensions</h3>

<p>As extensões externas são idênticas às <em>bundled</em> em quase todos os aspectos. Elas vêm com o PHP, podem ser habilitadas
ou não e são mantidas pela equipe do <em>core</em>, porém possuem uma diferença: elas possuem dependências externas.</p>

<p>Para ter este tipo de extensão em sua instalação do PHP você vai precisar ter alguma outra biblioteca ou programa em seu
sistema operacional. A extensão <em>cURL</em>, por exemplo, entra nessa categoria. Para ter essa extensão no PHP você precisa
do software <em>cURL</em> instalado no sistema, já que a extensão faz uso do código disponibilizado por este software.</p>

<p>Alguns exemplos de extensões externas são: cURL, DOM, OpenSSL, Sodium, Zip etc.</p>

<h3 id="pecl-extensions">PECL Extensions</h3>

<p>Por último nós temos as extensões disponibilizadas por terceiros usando <em>PECL</em>, que é basicamente um repositório para
extensões PHP, como se fosse o <em>Packagist</em> de extensões. Se você pretende criar uma extensão para o PHP, vai utilizar
este repositório.</p>

<p>As extensões desta categoria são mantidas por terceiros e podem ou não possuir dependências externas. Nem todas as
extensões desta categoria estão no manual da linguagem, afinal de contas é possível que qualquer pessoa crie uma
extensão.</p>

<p>Alguns exemplos interessantes de extensões disponibilizadas através do <em>PECL</em>: DS (Data Structures), EV, Memcached,
Parallel, Swoole etc.</p>

<h2 id="refer%C3%AAncias">Referências</h2>

<p>Conhecer todas extensões do PHP é simplesmente impossível, mas conhecer bem algumas extensões mais importantes para seu
dia-a-dia é de extrema importância.</p>

<p><a href="https://www.php.net/manual/en/extensions.membership.php">Aqui</a> você pode conferir a lista completa de extensões do
manual do PHP, todas classificadas por categoria.</p>

<p>Se você tiver interesse em criar suas próprias extensões, existem alguns materiais interessantes disponíveis (embora
não seja uma tarefa tão trivial). No tutorial <em><a href="https://flavioheleno.github.io/how-do-i/">How do I</a></em> do Flavio Heleno
você pode conferir o início dessa jornada de criação de extensões além de conferir outras referências.</p>

<h2 id="conclus%C3%A3o">Conclusão</h2>

<p>A linguagem de programação PHP é escrita em C e possui diversas extensões que fazem parte ou não da linguagem. Nós
fazemos uso de várias extensões no dia-a-dia e entender este funcionamento é bastante importante para devs PHP.</p>

<p>Se além de entender sobre algumas extensões você quiser aprender mais sobre PHP em si, você pode usar esse
<a href="https://tidd.ly/4d42Myb">cupom</a> que fornece 10% de desconto na assinatura da Alura, plataforma onde
eu mesmo gravei diversos cursos sobre o assunto.</p>
]]></content>
        </entry>
    </feed>